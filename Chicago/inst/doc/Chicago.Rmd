---
title: "CHiCAGO Vignette"
VignetteIndexEntry: 
output:
  BiocStyle::html_document:
    toc: true
bibliography: Chicago.bib
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{CHiCAGO Vignette}
%\VignetteDepends{}
%\VignetteKeywords{Chicago}
%\VignettePackage{Chicago}
-->
```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

## Introduction

This vignette will walk you through a typical CHiCAGO analysis. 

NOTE: A wrapper to perform this type of analysis, called *runChicago.R*, is provided as part of *chicagoTools*, which is available from our [Bitbucket repository](https://bitbucket.org/chicagoTeam/chicago/src).

WARNING: The data set used in this tutorial comes from the package *PCHiCdata*. This package contains a small part of the real data set (two chromosomes) from Schoenfelder et al [@Schoenfelder2015] (note that both papers used a different interaction calling algorithm and we are only reusing raw data from them). Do not use any of these sample input data for purposes other than training - download full BAM files and restart the analysis from them instead. 

Here we are going to use the data sample from mouse embryonic stem cells (mESCs) [@Schoenfelder2015]:

```{r}
library(PCHiCdata)
```

## Input files required

Before you start, you will need: 

1. Five restriction map information files:

- Restriction map file (.rmap) - a bed file containing coordinates of the restriction fragments. By default, 4 columns: chr, start, end, fragmentID.
- Bait map file (.baitmap) - a bed file containing coordinates of the baited restriction fragments, and their associated annotations. By default, 5 columns: chr, start, end, fragmentID, geneName.
- *nperbin* file (.npb), *nbaitsperbin* file (.nbpb), *proxOE* file (.poe) - Precompute these tables from the .rmap and .baitmap files, using the Python scripts from *chicagoTools* at our [Bitbucket repository](https://bitbucket.org/chicagoTeam/chicago/src): ``countNperBin.py``, ``countNbaitsPerBin.py`` and ``getProxOE.py``. Refer to ``chicagoTools`` README file for more details.

It is easiest to put all of these files in the same directory. An examples of a valid design, for a two-chromosome sample of the mESC data used in this vignette, is provided in the PCHiCdata package, as follows.

```{r}
dataPath <- system.file("extdata", package="PCHiCdata")
testDesignDir <- file.path(dataPath, "mm9TestDesign")
dir(testDesignDir)
```

2. You will also need your input data files. These files can be obtained from aligned capture HiC BAM files (generated from the raw fastq files, for example, using [HiCUP] http://www.bioinformatics.babraham.ac.uk/projects/hicup/) by running ``bam2chicago.sh``, available as part of ``chicagoTools``. Normally, the names of these input files end with *.chinput*.

```{r}
testDataPath <- file.path(dataPath, "mESCchinputFiles")
dir(testDataPath)

files <- c(
    file.path(testDataPath, "mESCrep1.chinput"),
    file.path(testDataPath, "mESCrep2.chinput")
  )
```

OPTIONAL: Because this data set is smaller than usual, we need to input some custom settings:

```{r}
settingsFile <- file.path(system.file("extdata", package="PCHiCdata"), "smESCSettings", "smESC.settingsFile")
```

Normally, you will not have to do this.

## Example workflow

We run CHiCAGO on the test data as follows. First, we create a blank ``chicagoData`` object, and we tell it where the design files are. For this example, we also provide the optional settings file.

```{r, message=FALSE}
library(Chicago)

cd <- setExperiment(designDir = testDesignDir, settingsFile = settingsFile)
```

The properties of ``chicagoData`` objects are discussed more in [The chicagoData object](#link).

Next, we read in the input data files:

```{r, message=FALSE}
cd <- readAndMerge(files=files, cd=cd)
```

Finally, we run the pipeline with ``chicagoPipeline()``:

```{r, eval=FALSE}
cd <- chicagoPipeline(cd)
```

## Output plots

``chicagoPipeline()`` produces a number of plots. You can save these to disk by setting the ``outprefix`` argument in ``chicagoPipeline()``.

The plots are as follows:

1. Brownian noise other end factors: The adjustment made to the mean Brownian noise count, based on the class of the other end. ("tlb" refers to the number of trans reads the other end has, in total. "B2B" stands for a "bait-to-bait" interaction.)
2. Technical noise estimates: The mean number of technical noise reads expected for other ends and baits, respectively, in certain classes. These classes, displayed on the x axis, again refer to the number of trans reads that the other end has.
3. Distance function: The mean number of Brownian noise reads expected for an ``average`` bait, as a function of distance, plotted on a log-log scale.

```{r, echo=FALSE, message=FALSE}
cd <- chicagoPipeline(cd)
```

## Output files

You can export the results to disk, using ``exportResults()``. (If you use *runChicago.R*, the files appear in ./\<results-folder\>/data). By default, the function outputs three different output file formats:

```{r}
outputDirectory <- tempdir()
exportResults(cd, file.path(outputDirectory, "vignetteOutput"))
```

Each called interaction is assigned a score that represents how strong CHiCAGO believes the interaction is: formally, it is -log(adjusted P-value). Thus, a larger score represents a stronger interaction. In each case, the score threshold of -log(adjusted p-value) of 5 is applied.

Summary of output files:

ibed format (ends with ...ibed):

- each row represents an interaction
- first four columns give information about the chromosome, start, end and name of the bait fragment
- next four columns give information about the chromosome, start, end and name of the other end that interacts with the bait fragment
- N\_reads is the number of reads
- score is as defined above

seqmonk format (ends with ...seqmonk.txt)

- Can be read by [seqmonk](http://www.bioinformatics.babraham.ac.uk/projects/seqmonk/).
- An interaction is represented by two rows: the first row is the bait, the second the other end. Thus, the file alternates: bait1, otherEnd1, bait2, otherEnd2, ...
- Columns are: chromosome, start, end, name, number of reads, interaction score (see above)

washU\_text format (ends with ...washU\_text.txt)

- Can be read by the [WashU browser](http://epigenomegateway.wustl.edu)
- Upload via the "Got text files instead? Upload them from your computer" link.
- Note - Advanced users may wish to export to washU\_track format instead. See the help page for ``exportResults()``.

For bait-to-bait interactions, the interaction can be tested either way round (i.e. either fragment can be considered the "bait"). In most output formats, both of these tests are preserved. The exception is washU output, where these scores are consolidated by taking the maximum.

## Peak enrichment for features

``peakEnrichment4Features()`` tests the hypothesis that other ends in the CHiCAGO output are enriched for genomic features of interest - for example, histone marks associated with enhancers. We find out how many overlaps are expected under the null hypothesis (i.e. that there is no enrichment) by shuffling the other ends around in the genome, while preserving the overall distribution of distances over which interactions span.

You will need additional files to perform this analysis - namely, a .bed file for each feature. We include ChIP-seq data from the ENCODE consortium [@encode_integrated_2012], again restricted to chr18 and chr19. (Data accession numbers: Snyder lab GSM1003750, GSM1003756, GSM1003751; Ren lab GSM1000126, Hardison lab ENCFF001ZJO, ENCFF001ZQY)

First, we find the folder that contains the features, and construct a list of the features to use:

```{r}
featuresFolder <- file.path(dataPath, "mESCfeatures")
dir(featuresFolder)

featuresFile <- file.path(featuresFolder, "featuresmESC.txt")
featuresTable <- read.delim(featuresFile, header=FALSE, as.is=TRUE)
featuresList <- as.list(featuresTable$V2)
names(featuresList) <- featuresTable$V1
featuresList
```

Next, we feed this information into the ``peakEnrichment4Features()`` function.

As part of the analysis, ``peakEnrichment4Features()`` takes a distance range (by default, the full distance range over which interactions are observed), and divides it into some number of bins. We must select the number of bins; here, we choose that number to ensure that the bin size is approximately 10kb. If the defaults are changed, a different number of bins is more appropriate. See ``?peakEnrichment4Features`` for more information.

```{r, message=FALSE}
no_bins <- ceiling(max(abs(cd@x$distSign), na.rm = T)/1e4)

enrichmentResults <- peakEnrichment4Features(cd, folder=featuresFolder, list_frag=featuresList,
                                             no_bins=no_bins, sample_number=100)
```

Note the plot produced by this function. For each feature type, the yellow bar represents the number of features that overlap with interaction other ends. The blue bar represents what would be expected by chance, with a 95\% confidence interval for the mean number of overlaps plotted. If the yellow bar lies outside of this interval, we reject the null hypothesis, thus concluding that there is enrichment/depletion of that feature.

In addition, this information is returned in tabular form:

```{r}
enrichmentResults
```

## The chicagoData object {#cd}

In the above workflows, *cd* is a *chicagoData* object. It contains three elements:

* ``cd@x`` is a `r CRANpkg("data.table")` (note: not a *data.frame*) that contains information about fragment pairs.
* ``cd@settings`` is a list of settings, usually set with the setExperiment() function.
* ``cd@params`` is a list of parameters. This list is populated as the pipeline runs, and CHiCAGO estimates them in turn.

A closer look at ``cd@x``:
```{r}
head(cd@x, 2)
```

Columns:

* baitID: ID of baited fragment
* otherEndID: ID of other end fragment
* s_j: bait-specific scaling factor (Brownian noise)
* otherEndLen: The length of the other end fragment
* distSign: The distance from the baited fragment to the other end fragment. Positive and negative values indicate that the other end is, respectively, $5'$ and $3'$ of the baited fragment. NA indicates a trans interactions.
* isBait2Bait: TRUE if the other end fragment is also a baited fragment
* N.1, N.2, ...: Raw read counts per replicate (see ``?mergeSamples``).
* N: Merged count (see ``?mergeSamples``) or raw count in the case of single-replicate interaction calling.
* refBinMean: Can be ignored. (see ``?normaliseBaits``)
* s_i: other end-specific scaling factor (Brownian noise)
* NNb: "N normalised for baits", a count scaled up by accounting for s_j. May be useful for visualization.
* NNboe: "N normalised for baits and other ends"; may be useful for visualization.
* tlb: Class of other end, based on the number of fragments on other chromosomes that have read pairs.
* tblb: As tlb, for the bait fragment.
* Tmean: Expected count from technical noise.
* Bmean: Expected count from Brownian noise. (Thus, the expected count under the null hypothesis is Tmean + Bmean.)
* log.p: p-value associated with fragment pair, on log-scale.
* log.w: p-value weight, on log-scale.
* log.q: weighted p-value, on log-scale.
* score: Final CHiCAGO score.

**WARNING:** Many functions in CHiCAGO update ``cd@x`` by reference, which means that ``cd@x`` can change even when you do not explicitly assign to it.
To avoid this behaviour, copy the *chicagoData* object first:

```{r}
newCd = copyCD(cd)
```

##Session info

```{r}
sessionInfo()
```

##References
<!-- the bibliography automatically gets appended here -->
