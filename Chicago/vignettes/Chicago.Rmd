---
title: "CHiCAGO Vignette"
VignetteIndexEntry: 
output:
  BiocStyle::html_document:
    toc: true
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{CHiCAGO Vignette}
%\VignetteDepends{}
%\VignetteKeywords{Chicago}
%\VignettePackage{Chicago}
-->
```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

## Introduction

This vignette will walk you through a typical CHiCAGO analysis.

A wrapper to perform the analysis, called *runChicago.R*, can be found on our website: [FIXME URL].

WARNING: The data set used in this tutorial is only a small part of a real data set. Do not use any of the input data in your own analysis. We will release a companion data package that has a fully executable workflow.

## Input files required

Before you start, you will need: 

1. Five restriction map information files:

- Restriction map file (.rmap) - a bed file containing coordinates of the restriction fragments. By default, 4 columns: chr, start, end, fragmentID.
- Bait map file (.baitmap) - a bed file containing coordinates of the baited restriction fragments, and their associated annotations. By default, 5 columns: chr, start, end, fragmentID, geneName.
- *nperbin* file (.npb), *nbaitsperbin* file (.nbpb), proxOEfile (.poe) - Precompute these tables from the .rmap and .baitmap files, using the Python scripts *countNperBin.py*, *countNbaitsPerBin.py* and *getProxOE.py*. 

It is easiest to put all of these files in the same directory. If you are using a standard restriction enzyme and bait map, you can use the files on our website, otherwise you will need to generate them yourself using CHiCTools, also available on our website.

Examples of these files are also provided in the package, as follows. Do not use these files in your analysis!

```{r}
dataPath <- system.file("extdata", package="Chicago")
testDesignDir <- file.path(dataPath, "unitTestDesign")
dir(testDesignDir)
```

2. You will also need your input data files. These files can be obtained by running bam2chicago.sh. Normally, the names of these input files end with *.chinput*.

```{r}
testDataPath <- file.path(dataPath, "unitTestData")
files <- c(
    file.path(testDataPath, "unitTest_mESC_rep1.chinput"),
    file.path(testDataPath, "unitTest_mESC_rep2.chinput")
  )
files
```

## Example workflow

We apply CHiCAGO to the test data as follows. First, we create a blank ``ChicagoData`` object, and we tell it where the design files are. (If we want to change any settings, we can do that here.)

```{r, message=FALSE}
library(Chicago)

cd <- setExperiment(designDir = testDesignDir)
```

The properties of ``ChicagoData`` objects are discussed more in [The ChicagoData object](#link).

Next, we read in the samples:

```{r, message=FALSE}
cd <- readAndMerge(files=files, cd=cd)
```

Finally, we run the pipeline. Note that this command will fail on the example data set, because we don't have enough data. A pre-analysed data set is provided in the next section.

```{r, eval=FALSE}
cd <- chicagoPipeline(cd)
```

``chicagoPipeline()`` produces a number of plots. You can save these to disk by setting the ``outprefix`` argument.

For use in the next section, we load a pre-analysed data set as follows:



## Output files

You can export the results to disk, using ``exportResults()``. (If you use *runChicago.R*, the files appear in ./\<results-folder\>/data.)

Each called interaction is assigned a score that represents how strong CHiCAGO believes the interaction is: formally, it is -log(adjusted P-value). Thus, a larger score represents a stronger interaction. In each case, the score threshold of -log(adjusted p-value) of 5 is applied.

Summary of output files:

ibed format (ends with ...ibed):

- each row represents an interaction
- first four columns give information about the chromosome, start, end and name of the bait fragment
- next four columns give information about the chromosome, start, end and name of the other end that interacts with the bait fragment
- N\_reads is the number of reads
- score is as defined above

seqmonk format (ends with ...seqmonk.txt)

- Can be read by seqmonk (http://www.bioinformatics.babraham.ac.uk/projects/seqmonk/)
- An interaction is represented by two rows: the first row is the bait, the second the other end. Thus, the file alternates: bait1, otherEnd1, bait2, otherEnd2, ...
- Columns are: chromosome, start, end, name, number of reads, interaction score (see above)

washU\_text format (ends with ...washU\_text.txt)

- Can be read by WashU browser (epigenomegateway.wustl.edu)
- Upload via the "Got text files instead? Upload them from your computer" link.
- FIXME

washU\_track format (ends with ...washU\_track.txt)

- Can be read by WashU browser (epigenomegateway.wustl.edu)
- An interaction is represented by two rows, with each representing one of the fragments involved in the interaction. However, the two rows need not be adjacent.
- First three columns are: chromosome, start, end. Column four is of form [Chr]:[Start]-[End],[Score], which gives the genomic coordinates of the interacting fragment, and the interaction score (see above). The remaining columns can be ignored.


**The data frame x** used to produce these files (one row per interaction) is stored in the .RDa file in the same folder.

The /examples folder contains PDFs with bait profiles for 25 random baits - for full chromosome length and zoomed in to 1Mb, respectively.

**The /overlap_plots folder** contains barplots showing the numbers of "enhancers" overlapping with genomic features of choice (yellow bars) versus the expected numbers computed using randomly sampled fragments chosen such that their distribution of distances from promoters matches that for the "enhancers". Currently these overlaps are computed for interactions within 1 Mb from their respective baits only.

## Output plots

**In the /diag_plots folder**, we currently store diagnostic plots for other end normalisation and technical noise estimation, but more will be added.


and various plots in the other subfolders of ./\<results-folder\>. 

Describe each key plot in turn

```{r}
#FIXME
```

## Peak enrichment for features

``peakEnrichment4Features()`` tests the hypothesis that other ends in the CHiCAGO output are enriched for genomic features of interest - for example, histone marks associated with enhancers. You will need additional files to perform this analysis - namely, a .bed file for each feature:

```{r}
#FIXME
```

## The ChicagoData object {#cd}

In the above workflow, *cd* is a *ChicagoData* object. It contains three elements:

* ``cd@x`` is a `r CRANpkg("data.table")` (note: not a *data.frame*) that contains information about fragment pairs.
* ``cd@settings`` is a list of settings, usually set with the setExperiment() function.
* ``cd@params`` is a list of parameters. This list is populated as the pipeline runs, and CHiCAGO estimates them in turn.

**WARNING:** Many functions in CHiCAGO update ``cd@x`` by reference, which means that ``cd@x`` can change even when you do not explicitly assign to it.
To avoid this behaviour, copy the *chicagoData* object first:

| cdCopy <- copy(cd)
| cdCopy <- FIXME(cdCopy)
| identical(cd, cdCopy)


##Session info

```{r}
sessionInfo()
```
