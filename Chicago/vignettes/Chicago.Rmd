---
title: "CHiCAGO Vignette"
VignetteIndexEntry: 
output:
  BiocStyle::html_document:
    toc: true
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{CHiCAGO Vignette}
%\VignetteDepends{}
%\VignetteKeywords{Chicago}
%\VignettePackage{Chicago}
-->
```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

## Introduction

This vignette will walk you through a typical CHiCAGO analysis.

A wrapper to perform the analysis, called *runChicago.R*, can be found on our website: [FIXME URL].

WARNING: The data set used in this tutorial is only a small part of a real data set. Do not use any of the input data in your own analysis. We will release a companion data package that has a fully executable workflow.

## Input files required

Before you start, you will need: 

1. Five restriction map information files:

- Restriction map file (.rmap) - a bed file containing coordinates of the restriction fragments. By default, 4 columns: chr, start, end, fragmentID.
- Bait map file (.baitmap) - a bed file containing coordinates of the baited restriction fragments, and their associated annotations. By default, 5 columns: chr, start, end, fragmentID, geneName.
- *nperbin* file (.npb), *nbaitsperbin* file (.nbpb), proxOEfile (.poe) - Precompute these tables from the .rmap and .baitmap files, using the Python scripts *countNperBin.py*, *countNbaitsPerBin.py* and *getProxOE.py*. 

It is easiest to put all of these files in the same directory. If you are using a standard restriction enzyme and bait map, you can use the files on our website [FIXME URL], otherwise you will need to generate them yourself using CHiCTools, also available on our website.

Examples of these files are also provided in the package, as follows. Do not use these files in your analysis!

```{r}
dataPath <- system.file("extdata", package="Chicago")
testDesignDir <- file.path(dataPath, "unitTestDesign")
dir(testDesignDir)
```

2. You will also need your input data files. These files can be obtained by running bam2chicago.sh, available from our website [FIXME URL]. Normally, the names of these input files end with *.chinput*.

```{r}
testDataPath <- file.path(dataPath, "unitTestData")
dir(testDataPath)

files <- c(
    file.path(testDataPath, "unitTest_mESC_rep1.chinput"),
    file.path(testDataPath, "unitTest_mESC_rep2.chinput")
  )
```

## Example workflow

We run CHiCAGO on the test data as follows. First, we create a blank ``ChicagoData`` object, and we tell it where the design files are. (If we want to change any other settings, we would do that here.)

```{r, message=FALSE}
library(Chicago)

cd <- setExperiment(designDir = testDesignDir)
```

The properties of ``ChicagoData`` objects are discussed more in [The ChicagoData object](#link).

Next, we read in the samples:

```{r, message=FALSE}
cd <- readAndMerge(files=files, cd=cd)
```

Finally, we run the pipeline. Note that this command will fail on the example data set, because we don't have enough data. A pre-analysed data set is provided in the next section.

```{r, eval=FALSE}
cd <- chicagoPipeline(cd)
```

``chicagoPipeline()`` produces a number of plots. You can save these to disk by setting the ``outprefix`` argument.

For use in the next section, we load a pre-analysed data set as follows:

```{r}
data(cdUnitTest)
```

## Output files

You can export the results to disk, using ``exportResults()``. (If you use *runChicago.R*, the files appear in ./\<results-folder\>/data.)

Each called interaction is assigned a score that represents how strong CHiCAGO believes the interaction is: formally, it is -log(adjusted P-value). Thus, a larger score represents a stronger interaction. In each case, the score threshold of -log(adjusted p-value) of 5 is applied.

Summary of output files:

ibed format (ends with ...ibed):

- each row represents an interaction
- first four columns give information about the chromosome, start, end and name of the bait fragment
- next four columns give information about the chromosome, start, end and name of the other end that interacts with the bait fragment
- N\_reads is the number of reads
- score is as defined above

seqmonk format (ends with ...seqmonk.txt)

- Can be read by seqmonk (http://www.bioinformatics.babraham.ac.uk/projects/seqmonk/)
- An interaction is represented by two rows: the first row is the bait, the second the other end. Thus, the file alternates: bait1, otherEnd1, bait2, otherEnd2, ...
- Columns are: chromosome, start, end, name, number of reads, interaction score (see above)

washU\_text format (ends with ...washU\_text.txt)

- Can be read by WashU browser (epigenomegateway.wustl.edu)
- Upload via the "Got text files instead? Upload them from your computer" link.
- Note - Advanced users may wish to export to washU\_track format instead. See the help page for ``exportResults()``.

## Output plots

Describe each key plot in turn

```{r}
#FIXME
```

## Peak enrichment for features

``peakEnrichment4Features()`` tests the hypothesis that other ends in the CHiCAGO output are enriched for genomic features of interest - for example, histone marks associated with enhancers. You will need additional files to perform this analysis - namely, a .bed file for each feature:

```{r}
#FIXME
```

## The ChicagoData object {#cd}

In the above workflow, *cd* is a *ChicagoData* object. It contains three elements:

* ``cd@x`` is a `r CRANpkg("data.table")` (note: not a *data.frame*) that contains information about fragment pairs.
* ``cd@settings`` is a list of settings, usually set with the setExperiment() function.
* ``cd@params`` is a list of parameters. This list is populated as the pipeline runs, and CHiCAGO estimates them in turn.

A closer look at ``cd@x``:
```{r}
head(cdUnitTest@x, 2)
```

Columns:
* baitID: ID of baited fragment
* otherEndID: ID of other end fragment
* s_j: bait-specific scaling factor (Brownian noise)
* otherEndLen: The length of the other end fragment
* distSign: The distance from the baited fragment to the other end fragment. (NA for trans interactions.)
* isBait2Bait: TRUE if the other end fragment is also a baited fragment
* N.1, N.2: Normalized counts (see ``?mergeSamples``).
* N: Merged count (see ``?mergeSamples``).
* refBinMean: Can be ignored. (see ``?normaliseBaits``)
* s_i: other end-specific scaling factor (Brownian noise)
* NNb: "N normalised for baits"; FIXME
* NNboe: "N normalised for baits and other ends"; FIXME
* tlb: 
* Tmean: Expected count from technical noise.
* Bmean: Expected count from Brownian noise.
* log.p: 
* log.w: 
* log.q: 
* score: Final CHiCAGO score.

**WARNING:** Many functions in CHiCAGO update ``cd@x`` by reference, which means that ``cd@x`` can change even when you do not explicitly assign to it.
To avoid this behaviour, copy the *chicagoData* object first:

```{r}
cdCopy <- cdUnitTest
cdCopy@x <- copy(cdUnitTest@x)
```

We will provide an explicit function to do this in due course.

##Session info

```{r}
sessionInfo()
```
