#!/usr/bin/perl

use strict;
use warnings;
use File::Basename;
use Getopt::Long;
use FindBin '$Bin';
use lib $Bin;
use File::Temp qw/ tempfile tempdir /;

use Data::Dumper;


##########################################################
#Get user-supplied parameters
#Option variables
my %config = (
	digestfolder => '',
	features => '',
	input => '',
	email => '',
	help => '',
	hold_jid => '',
	config => '',
	settings => '',
	matrix => '',
	map => '',
);

if ( !@ARGV ) {    #No arguments, no files
    print while (<DATA>);
    exit(0);
}

my $config_result = GetOptions(    #Stores parameters
	"digestfolder=s" => \$config{digestfolder},
	"features" =>	\$config{features},
	"input=s"   => \$config{input},
	"email=s"   => \$config{email},
	"help"   => \$config{help},
	"hold_jid=s" => \$config{hold_jid},
	"config=s"   => \$config{config},
	"settings=s" => \$config{settings},
    "matrix" => \$config{matrix},
	"map" => \$config{map}
	);

die "Command line options need to be in the correct format (chicago --help for more details).\n" unless ($config_result);



my $baits;
my $digest;

my @inputData;    #Array of arrays storing the data from the input file

if ( $config{help} ) {
    print while (<DATA>);
    exit(0);
}


if( hasval($config{map}) ){
	die "Specify i) digest file and ii) oligos file\n" unless( scalar @ARGV == 2);
	my ($digest_file, $oligo_file) = @ARGV;
	my $email = `whoami`;
	chomp $email;
	$email .= '@babraham.ac.uk';
	my $random_string = generateRandomString(10); 
	my $step1_job_id = "makeFiles.$random_string";
	my $step2_job_id = "makeDesign.$random_string";
	
	#Make baitmap and Rmap
	my $command = "$Bin/chicagoTools/create_baitmap_rmap.pl $digest_file $oligo_file";
	my $cluster_command = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=20G -o $step1_job_id.out -j y -N $step1_job_id -m eas -M $email";	
	!system($cluster_command) or die "Could not run cluster command: '$cluster_command'\n";
	
	#Make remaining files
	$command = "python $Bin/chicagoTools/makeDesignFiles.py";
	$cluster_command = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=20G -o $step2_job_id.out -j y -N $step2_job_id -m eas -M $email -hold_jid $step1_job_id";	
	!system($cluster_command) or die "Could not run cluster command: '$cluster_command'\n";

	print "Jobs sent to Cluster.\n";
	
	exit (0);
}


if( hasval($config{matrix}) ){    #Running the peak matrix only
	die "Please specify input files for generating a peak martix.\n" unless @ARGV;
	my @files = deduplicate_array(@ARGV);
	check_files_exist(\@files, 'EXISTS');
	print "Option --matrix selected, generating Peak Matrix only\n";
	open(LOG, '>', 'chicagoPeakMatrixLog.txt') or die "Could not write to 'chicagoPeakMatrixLog.txt' : $!";
	run_peak_matrix('MATRIX_ONLY', $config{email}, @files);
	close LOG or die "Could not close 'chicagoPeakMatrixLog.txt' : $!";
	print "Processing complete.";
	exit (0);
} 


if( hasval($config{config}) ) {
	process_config($config{config}, \%config)
}

check_parameters();
processInputfile();
 
#Create a log file
open(LOG, '>', 'chicagoLog.txt') or die "Could not write to 'chicagoLog.txt' : $!";
	
#Launch pipeline step1
foreach my $array (@inputData){
	if( hasval($$array[1]) ){    #Prefix 1 is present
		my $inputFile = $$array[0];
		my $prefix1 = $$array[1];
		my $prefixRand = "$prefix1." . generateRandomString(6);
		my $step1_jid_string = '';
		if(hasval ($config{hold_jid}) ){
			$step1_jid_string = "-hold_jid $config{hold_jid}";
		}		
		my $command = "$Bin/chicagoTools/bam2chicago.sh $inputFile $baits $digest $prefix1";
		my $clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=100G -o CHiCAGO1.$prefixRand.out -j y -N CHiCAGO1.$prefixRand $config{email} $step1_jid_string";
		
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";
		print LOG "CHiCAGO_Step1:\t$clusterCommand\n";
		push( @$array, "CHiCAGO1.$prefixRand");
	}	
}

#Launch pipeline step2
my %prefixStep2Files;    # %{prefix2} = array of filename(s) to process
my %prefixStep2Features;  # %{prefix2} = features file to process
my %jids4Step2;    # %{prefix2} = array of Step1 job ids   

#Create the new data structures
foreach my $array (@inputData){  
	my $prefixStep1 = $$array[1];
	my $prefixStep2 = $$array[2];
	my $file = $$array[0];
	my $jid = $$array[4];
	
	if(hasval($prefixStep1) ){
		$file = calcStep1Outfile($prefixStep1);
		push( @{ $jids4Step2{$prefixStep2} }, $jid); 
	}
	
	my $features = $$array[3];
	push( @{ $prefixStep2Files{$prefixStep2} }, $file);
	$prefixStep2Features{$prefixStep2} = $features;
}


#Send step2 jobs to the cluster
my @submittedStep2Jobs;   #Stores the names of jobs submitted to the cluster in order. Even sent to node 0, odd to node 1

if($config{features}){

	#Check prefix2 all unique
	my $parameters_ok = 1;
	foreach my $prefixStep2 (keys %prefixStep2Files){
		my @files = @{ $prefixStep2Files{$prefixStep2} };
		my $numberFiles = scalar @files;

		if($numberFiles != 1){
			warn "Duplicate prefix2: $prefixStep2\n";
			$parameters_ok = 0;
		}
	}
	die "When running --features, all prefix 2 entries need to be different.\n" unless ($parameters_ok);
	
	
	#Send jobs to cluster
	foreach my $prefixStep2 (keys %prefixStep2Files){
		my $features = $prefixStep2Features{$prefixStep2};
		
		my @files = @{ $prefixStep2Files{$prefixStep2} };

		my $numberFiles = scalar @files;
		my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
		

		$features =~ /(.+\/)/;
		my $featuresFolder = $1;
		
		#Calculate jids (if necessary)
		my @jids;
		my $step2_jid_string = '';    #Jobs to wait for as defined by the user
		if(exists $jids4Step2{$prefixStep2} ){
			@jids = @{ $jids4Step2{$prefixStep2} };
			$step2_jid_string = join(',', @jids);
		}
		if(hasval ($config{hold_jid}) ){
			$step2_jid_string = $step2_jid_string . ',' . $config{hold_jid};
		}	
		if(hasval ($step2_jid_string) ){
			$step2_jid_string = "-hold_jid $step2_jid_string";
		}
		

		my $params = "--features-only --en-feat-folder $featuresFolder --en-feat-list $features";
		my $command = "Rscript $Bin/chicagoTools/runChicago.R $params $files[0] $prefixStep2";		

			my $prefix2Rand = basename($prefixStep2) . generateRandomString(6);    #To remove forward slashes in the job name (-N)				
			my $currentJobName = "CHiCAGO2.$prefix2Rand";
			push (@submittedStep2Jobs, $currentJobName);
			my $jobSent = scalar @submittedStep2Jobs;
			my $clusterCommand;	
						
			$clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=50G -o $prefix2Rand.out -j y -N $currentJobName $config{email} $step2_jid_string";	
					
			print LOG "CHiCAGO_Step2:\t$clusterCommand\n";	
			!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";	
	}
	
}else{

	foreach my $prefixStep2 (keys %prefixStep2Files){
		my $features = $prefixStep2Features{$prefixStep2};
		
		my @files = @{ $prefixStep2Files{$prefixStep2} };
		#@files = step1FileRenamer(@files);
		my $numberFiles = scalar @files;
		my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
		
		$features =~ /(.+\/)/;
		my $featuresFolder = $1;
		
		#Calculate jids (if necessary)
		my @jids;
		my $step2_jid_string = '';    #Jobs to wait for as defined by the user
		if(exists $jids4Step2{$prefixStep2} ){
			@jids = @{ $jids4Step2{$prefixStep2} };
			$step2_jid_string = join(',', @jids);
		}
		if(hasval ($config{hold_jid}) ){
			$step2_jid_string = $step2_jid_string . ',' . $config{hold_jid};
		}	
		if(hasval ($step2_jid_string) ){
			$step2_jid_string = "-hold_jid $step2_jid_string";
		}
		my $memory_allocation;
		if($numberFiles == 1){
			$memory_allocation = 'h_vmem=100G';
		}else{	
			my $mem = $numberFiles * 75;
			if ($mem > 400) {
				print "Capping memory allocation to 400Gb\n";
				$mem = 400;
			}
			$memory_allocation = 'h_vmem='.$mem.'G';

		}
		print "Requesting memory allocation: $memory_allocation\n";
		
		my $command;
		my $params = "--output-dir $outdir --en-feat-folder $featuresFolder --en-feat-list $features --design-dir $config{digestfolder} --export-format seqMonk,washU_text";
		if (hasval($config{settings})){
			$params .= " --settings-file $config{settings}";
		}

		if($numberFiles == 1){
			$command = "Rscript $Bin/chicagoTools/runChicago.R $params $files[0] $prefixStep2";		
		
		}else{
			my $filenameString = join(',', @files);
			$command = "Rscript $Bin/chicagoTools/runChicago.R $params $filenameString $prefixStep2";			
		}
			
			my $prefix2Rand = basename($prefixStep2) . generateRandomString(6);    #To remove forward slashes in the job name (-N)				
			my $currentJobName = "CHiCAGO2.$prefix2Rand";
			push (@submittedStep2Jobs, $currentJobName);
			my $jobSent = scalar @submittedStep2Jobs;
			my $clusterCommand;	
			$clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l $memory_allocation -o $prefix2Rand.out -j y -N $currentJobName $config{email} $step2_jid_string";	
					
			print LOG "CHiCAGO_Step2:\t$clusterCommand\n";	
			!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";	
	}
}

run_peak_matrix('CALCULATE_INPUTFILES', \%prefixStep2Files, \@submittedStep2Jobs, \%config);
		
close LOG or die "Could not close 'chicagoLog.txt' : $!";

print "Processing complete.\n";	
	
exit (0);



###########################################################################
#Subroutines
############################################################################
	
#Create Peak matrix	
sub run_peak_matrix{
	my $options = $_[0];
	
	#Create a peak matrix file for the R script to read
    my ($conf_fh, $conf_filename) = tempfile( 'peak_matrix_input.XXXXXXXX', SUFFIX => '.txt' );
	my $hold_jid_string = '';
	my $email = '';
	
	
	if($options eq 'MATRIX_ONLY'){
		my @files = @_;
		shift @files;    #Remove options variable
		my $email = shift @files;  
	
		foreach my $file (@files){
			my $name = $file; 
			$name =~ s/\.Rds//;
			print $conf_fh "$name\t$file\n"; 
		}
	
	}elsif($options eq 'CALCULATE_INPUTFILES'){
	
		my (undef, $prefixStep2Files_hash_ref, $hold_jid_ref, $config_hash_ref) = @_;
			
		foreach my $prefix ( keys %{ $prefixStep2Files_hash_ref } ){
			my $step2_outfile = 'res_' . $prefix . '_chicago2/data/' . "$prefix.Rds";
			print $conf_fh "$prefix\t$step2_outfile\n"; 
		
		}
		
		$hold_jid_string = join(',', @$hold_jid_ref);
		$hold_jid_string = '-hold_jid ' . $hold_jid_string;
		$email = $$config_hash_ref{email};
		
	}else{
		die "Subroutine 'run_peak_matrix' passed invalid options parameter: '$options'\n";
	}
	close $conf_fh or die "Could not close '$conf_filename' : $!";
	
	
	#Send the job to the cluster
	my $random_string = generateRandomString(6);
	my $outfile = "Peak_Matrix.CHiCAGO.$random_string";
	my $jobname = $outfile;

	
	my $command = "Rscript $Bin/chicagoTools/makePeakMatrix.R --twopass $conf_filename $outfile";
	my $clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=200G -o $jobname.out -j y -N $jobname $email $hold_jid_string";	
	print LOG "$clusterCommand\n";
	!system($clusterCommand) or die "Could not generate Peak Matrix: '$clusterCommand'\n";
	#unlink $conf_filename or warn "Could not delete $conf_filename\n";   - Don't delete this file, else file will be deleted before cluster job starts
}	
	


#Takes the prefix for Step 1 and calculates the path and name of the
#file produced by CHiCAGO step1
sub calcStep1Outfile{
	my $prefix = $_[0];
	my $outFile = $prefix . '/' . $prefix . '.chinput';
	return $outFile;
}



#Create a random letter string
#Takes a number for the length of
#the string and returns the string
sub generateRandomString{
	my $length = $_[0];
	
	my @chars = ("A".."Z", "a".."z");
	my $string;
	$string .= $chars[rand @chars] for 1..$length;
	
	return $string;
}



#Confirms that output directory, features file,
#data files baits and digest fragments exist
sub check_parameters{
	my $parameters_ok = 1;
	
	#Add path to digest and bait filenames
	if( hasval ($config{digestfolder}) ){	
		$config{digestfolder} = $config{digestfolder} . '/' unless $config{digestfolder} =~ /\/$/;
	}else{
		$config{digestfolder} = './';
		warn "Using current working directory as digest folder\n";
	}
	
	#Check baits exist
	if (!defined($baits)){ $baits = "" };
	unless(-e $baits){
			opendir(DIR, $config{digestfolder}) || die ("Could not open digest dir $config{digestfolder}");
			my @baitmapfiles = grep(/\.baitmap$/,readdir(DIR));
			closedir(DIR);
			if(scalar(@baitmapfiles)==1){
				warn "Found baits file $baitmapfiles[0] in $config{digestfolder}\n";
				$baits = $config{digestfolder} . '/' . $baitmapfiles[0];
			}
			else{
				warn "Baits file '$baits' does not exist\n";
				$parameters_ok = 0;
			}
	}

	#Check digest exists
	if (!defined($digest)){ $digest = "" };
	unless(-e $digest){
			opendir(DIR, $config{digestfolder}) || die ("Could not open digest dir $config{digestfolder}");;
			my @digestfiles = grep(/\.rmap$/,readdir(DIR));
			closedir(DIR);
			if(scalar(@digestfiles)==1){
				warn "Found digest file $digestfiles[0] in $config{digestfolder}\n";
				$digest = $config{digestfolder} . '/' . $digestfiles[0];
			}
			else{
				warn "Digest file '$digest' does not exist\n";
				$parameters_ok = 0;
			}
	}
	
	if(hasval ($config{input}) ){
		unless(-e $config{input}){
			warn "Input file '$config{input}' does not exist\n";
			$parameters_ok = 0;
		}
	}else{
		warn "Please specify an --input file\n";
		$parameters_ok = 0;		
	}
	
	
	#Read the input file and check everything is fine
	if( (hasval ($config{input})) and (-e $config{input}) ){	
		my @data_files;
		my @features_files;
		
		open(INPUT_FILE, '<', $config{input}) or die "Could not open '$config{input}' : $!";
		while(<INPUT_FILE>){
			my $line = $_;
			chomp $line;
			next if($line =~ /^\s*$/);
			my ($data_file, undef, undef, $feature_file) = split(/\t/, $line);
			
			if(defined $data_file){
				unless(defined $data_file) {
					warn "Need to specify a features file for data file '$data_file'\n";
					$parameters_ok = 0;
				}
			}			
			push(@data_files, $data_file);
			push(@features_files, $feature_file);	
		}
		close INPUT_FILE or die "Could not close '$config{input}' : $!";
			
		if(@data_files){
			@data_files	= deduplicate_array(@data_files);
			@features_files = deduplicate_array(@features_files);
						
			$parameters_ok = 0 unless(check_files_exist(\@data_files, 'EXISTS'));
			$parameters_ok = 0 unless(check_files_exist(\@features_files, 'EXISTS'));	
		} else {
			warn "Specify file to process in the input list file\n";
			$parameters_ok = 0;
		}
		
		#Check the overlap control files exists and there are no duplicates in the features.txt (name by convention) file
		foreach my $feature_file (@features_files){
			my $feature_file_folder = dirname($feature_file);
			open(FEATURE_FILE, '<', $feature_file) or die "Could not open '$feature_file' : $!";
				my @feature_track_files;
				my @feature_track_descriptions;
				while(<FEATURE_FILE>){
					my $line = $_;
					chomp $line;
					next if($line =~ /^\s*$/);
					my ($description, $feature_track_file) = split(/\t/, $line);
					$feature_track_file = "$feature_file_folder/$feature_track_file";
					unless( (defined $description) and (defined $feature_track_file) ){
						warn "Feature file '$feature_file' contains empty fields\n";
						$parameters_ok = 0;
					}
					push(@feature_track_files, $feature_track_file) if defined($feature_track_file);					
					push(@feature_track_descriptions, $description) if defined($feature_track_file);
				}
			close FEATURE_FILE or die "Could not close $feature_file : $!";
					
			if( (scalar @feature_track_files) == (scalar deduplicate_array(@feature_track_files)) ){
				unless(check_files_exist(\@feature_track_files, 'EXISTS')){
					$parameters_ok = 0;
				}
			} else {
				warn "Features file '$feature_file' contains duplicate feature files\n";
				$parameters_ok = 0;
			}
			
			unless( (scalar @feature_track_descriptions) == (scalar deduplicate_array(@feature_track_descriptions)) ){
				warn "Features file '$feature_file' contains duplicate feature descriptions\n";
				$parameters_ok = 0;	
			}		
		}
	}
	
	if( hasval($config{email}) ){
		$config{email} = '-m eas -M ' . $config{email};
	}
	
	if( hasval($config{hold_jid}) ){
		my @hold_jid = split(/,/, $config{hold_jid});
		foreach my $jid (@hold_jid){
			unless($jid =~ /^\d+$/){
				warn "The --hold_jid parameter '$jid' needs to be an integer\n";
				$parameters_ok = 0;
			}	
		}
		$config{hold_jid} = join(',', @hold_jid);    #Better to use this than original (may contain ',,' etc.)
	}
	die "Please adjust configuration.\n" unless($parameters_ok);
}




#Subroutine: processInputfile
#Reads the inputfile and creates a datastructure
#Checks the data files exist
sub processInputfile{

	my $parameters_ok = 1;

	open(IN, '<', $config{input}) or die "Could not open '$config{input}' : $!";
	while(<IN>){
		my $line = $_;
		chomp $line;
		
		next if($line =~ /^\s*$/);
		
		my @lineArray = split(/\t/, $line);
		push(@inputData, [@lineArray]);
	
	
	}	
	close IN or die "Could not close $config{input}; : $!";
	
	#Check all input data files exit
	foreach my $array (@inputData){
		unless( -e $$array[0]){
			warn "Data file '$$array[0]' does not exist\n";
			$parameters_ok = 0;
		}	
	}
	
	#Check that all prefix1 entries are unique
	my %prefix1Count;
	foreach my $array (@inputData){
		if( hasval($$array[1]) ){
			$prefix1Count{$$array[1]}++;
		}	
	}
	foreach my $prefix1 (keys %prefix1Count){
		if($prefix1Count{$prefix1} > 1){
			warn "Prefix for step1 '$prefix1' appears $prefix1Count{$prefix1} times in the file '$config{input}'\n";
			$parameters_ok = 0;
		}
	}	
	
	
	#Check output directories don't already exist
	my %outputDirectories;
	my $alreadyExist = 0;
	foreach my $array (@inputData){
		my $step1Name = 'sample_' . $$array[1];
		my $step2Name = 'res_' . $$array[2];    #Check 'res' is output from CHiCAGO
	
		$outputDirectories{$step1Name} = '';    #Output folder name
		$outputDirectories{$step2Name} = '';    #Output folder name
	}
	
	foreach my $directory (keys %outputDirectories){
		$directory = $directory;
		if(-d $directory){
			warn "Output directory '$directory' already exists\n";
			$alreadyExist = 1;
		}
	}
	
	if($alreadyExist){
		my $reply = '';
		while( ($reply ne 'YES') and ($reply ne 'NO') ){
			warn "Do you want to overwrite the file in the output directories that alread exist [YES/NO]?\n";
			$reply = <STDIN>;
			chomp $reply;
			$reply = uc $reply;
		}
		
		if($reply eq 'NO'){
			$parameters_ok = 0;
		}
	
	}
	
	die "Please adjust configuration.\n" unless($parameters_ok);

}



############################
#Subroutine "process_config":
#Takes i) configuration file name and ii) %config hash (as a reference).
#The script then uses the configuration file to populate the hash as
#appropriate. Parameters passed via the command line take priority
#over those defined in the configuration file.
#The script modifies the hash directly, but returns as an array the lines in the configuration
#file that could did not correspond configuration parameters (these should be filenames).
sub process_config {
    my ( $config_file, $config_hash_ref ) = @_;
    my @non_parameters;    #Stores lines in the configuration file not defined as parameters

    #Open configuration file
    open( CONF, "$config_file" ) or die "Can't read $config_file: $!";

    while (<CONF>) {

        my $line = $_;
        chomp $line;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;    #Remove starting/trailing white spaces

        next if $line =~ /^\s*\#/;    #Ignore comments
        next if $line =~ /^\s*$/;     #Ignore whitespace
	
        #Check if this is a parameter
        my ( $parameter, $setting ) = split( /:/, $line );
        $parameter =~ s/^\s+//;
        $parameter =~ s/\s+$//;       #Remove starting/trailing white spaces
        $parameter = lc $parameter;
		$setting =~ s/^\s+// if defined ($setting);
        $setting =~ s/\s+$// if defined ($setting); 

		print "$parameter\t$setting\t\n";
		
        if ( exists $$config_hash_ref{$parameter} ) {
            if ( $$config_hash_ref{$parameter} eq '' ) {    #Check parameter not assigned value in command line
                $$config_hash_ref{$parameter} = $setting;    #Edit the configuration hash
            }
        } else {
            push( @non_parameters, $line );
        }
    }
    close CONF or die "Could not close filhandle on configuration file: '$config_file'\n";

    return @non_parameters;
}



###############################################################
#Sub: hasval
#Takes a string and returns true (i.e. '1') if the string has a value
#(i.e. is not equal to nothing (''). This is useful since some
#variables may be set to nothing allowing them to be evaluated
#without initialisation errors, while simultaneously containing
#no information.
sub hasval {
    if ( $_[0] ne '' ) {
        return 1;
    } else {
        return 0;
    }
}





##########################################
#Subroutine: check_files_exist
#Takes a reference to an array containing paths to filenames and verifies they exist
#Warns of files that do no exit. Returns 1 if all files exist but 0 if this is not
#the case.
#
#Also, takes a second argument:
#$_[1] should be 'EXISTS' or 'NOT_EXISTS'
#If 'NOT_EXISTS' warns if file already exists.  Returns '1' if none of the
#files exists and '0' if one or multiple files already exist
sub check_files_exist {
    my $files      = $_[0];    #Reference to array
    my $check_for  = $_[1];
    my $all_exist  = 1;
    my $not_exists = 1;

    if ( $check_for eq 'EXISTS' ) {
        foreach my $file (@$files) {
            unless ( -e $file ) {
                warn "File '$file' does not exist\n";
                $all_exist = 0;
            }
        }
    } elsif ( $check_for eq 'NOT_EXISTS' ) {
        foreach my $file (@$files) {
            if ( -e $file ) {
                warn "File '$file' already exists\n";
                $not_exists = 0;
            }
        }
    } else {
        die "Subroutine 'check_files_exist' requires argument 'EXISTS' or 'NOT_EXISTS'.\n";
    }

    if ( $check_for eq 'EXISTS' ) {
        return $all_exist;
    } else {
        return $not_exists;
    }
}


##########################################
#Subroutine: deduplicate_array
#Takes and array and returns the array with duplicates removed
#(keeping 1 copy of each unique entry).
sub deduplicate_array {
    my @array = @_;
    my %uniques;

    foreach (@array) {
        $uniques{$_} = '';
    }
    my @uniques_array = keys %uniques;
    return @uniques_array;
}


__DATA__

CHiCAGO Perl script controls the other programs in the CHiCAGO pipeline when using
The Babraham Institute Computing Cluster

SYNOPSIS

CHiCAGO [OPTIONS]... [Configuration FILE]...
CHICAGO [OPTIONS] --matrix [CHiCAGO output file for creating Peak Matrix]

FUNCTION

1) Creating the input List File
To run the pipeline create a tab-delimited List File, whose contents has the format:
Input_File     Step1_Prefix    Step2_Prefix    Features_File

The Input_File will either be a 1) HiCUP output BAM file or 2) a CHiCAGO Step1 output
file (*.chinput).

Output from CHiCAGO Step1 will be written to a folder named Step1_Prefix, which should 
be specified by the user.

Output from CHiCAGO Step2 will be written to a folder inluding the name Step1_Prefix.
This also should be specified by the user.

Provide the list to the Features_File. This file is itself a tab-delimited list of
all the features files e.g.:
DNase          C001UY46.DNase.hotspot_v3.20130415.bed
H3K27ac        C000S5H2.H3K27ac.ppqt_macs2_v2.20130415.bed
H3K27me3       C001UYH2.H3K27me3.ppqt_macs2_broad_v2.20130415.bed
H3K36me3       C000S5H2.H3K36me3.ppqt_macs2_broad_v2.20130415.bed
H3K4me1        C000S5H2.H3K4me1.ppqt_macs2_broad_v2.20130415.bed
H3K4me3        C000S5H2.H3K4me3.ppqt_macs2_v2.20130415.bed
hyper_meth     C000S5A1bs.hyper_meth.bs_call.20130415.bed


2) Create the configuration file
This should contain 3 items: i) Path to the Digest Folder that contains the *.baitmap, 
.baitmap_4col.txt (generated on the fly?), *.rmap, nbaitsperbin.nbpb, nperbin.npb and proxOEfile.poe
files); ii) address to send emails from Cluster and iii) path to the List File generated in Step1. 

Example content of the configuration file:
DigestFolder: /bi/home/wingetts/CHiCAGO/Digest_Mouse_NCBIM37_HindIII_None_reference_files
Email: steven.wingett@babraham.ac.uk
Input: hiup_paper_chicago_list.txt

3) Run CHiCAGO
chicago --config chicago.conf

4) Variations
i) Running Step1 only
Leave the Step2 and features columns blank (the input should be a BAM file)


ii) Running Step2 only
Leave the Step1 column blank (the input should be a *.chinput file.)

iii) Creating a features overlap plot only
chicago --config chicago.conf --features
 
iv) Creating a Peak Matrix only
chicago --matrix --email [Optional email address] [CHiCAGO output files to process]

COMMAND LINE OPTIONS

--config              	Specify the configuration file
--email                 Specify address to send email from Cluster (particularly
                        useful with --matrix option, which does not all this to be
                        specified using a configuration file						
--features              Process the features enrichment plots only
--help	              	Print program help and exit
--hold_jid            	Place jobs on hold until specified cluster jobs have completed
--map                   Makes Rmap, baitmap and other design files required by CHiCAGO.
                        Pass HiCUP digest file and oligos file (made by Simon Andrews'
                        script) as input
--matrix                Process CHiCAGO output files to generate a Peak Matrix file
--version             	Print the program version and exit
