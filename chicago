#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use FindBin '$Bin';
use lib $Bin;

use Data::Dumper;



##########################################################
#Get user-supplied parameters
#Option variables
my %config = (
	baits => '',
    digest  => '',
	input => '',
	email => '',
	help => '',
	config => '',
	
);

my $config_result = GetOptions(    #Stores parameters
    "baits=s"  => \$config{baits},
    "digest=s"  => \$config{digest},
    "input=s"   => \$config{input},
	"email=s"   => \$config{email},
	"help"   => \$config{help},
	"config=s"   => \$config{config}
	);

die "Command line options need to be in the correct format (chicago -help for more details).\n" unless ($config_result);

my @inputData;    #Array of arrays storing the data from the input file


if ( $config{help} ) {
    print while (<DATA>);
    exit(0);
}

if( hasval($config{config}) ) {
	process_config($config{config}, \%config)
}

check_parameters();
processInputfile();

# echo "/bi/home/paulafp/CHiCAGOv2/process_chic_single_core.sh
 # sample1742_lane2174_L006_uniques_captured.bam
  # /bi/group/sysgen/CHIC/Digest_Human_HindIII_baits.bed 
  # /bi/group/sysgen/CHIC/Digest_Human_HindIII.bed sample1742"| 
  # qsub -V -cwd -l vf=10G -pe orte 4 -o sample1742.out -j y -N sample1742 -m eas -M paulafp@babraham.ac.uk

#Launch pipeline step1
foreach my $array (@inputData){
	if( hasval($$array[1]) ){    #Prefix 1 is present
		my $inputFile = $$array[0];
		my $prefix1 = $$array[1];
		my $prefixRand = "$prefix1." . generateRandomString(6);
		my $command = "$Bin/process_chic_single_core.sh $inputFile $config{baits} $config{digest} $prefix1";
		my $clusterCommand = "echo \"$command\" | qsub -V -cwd -l vf=10G -pe orte 4 -o $prefixRand.out -j y -N $prefixRand $config{email}";
		print "CHiCAGO Step1: $inputFile\n";
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";
		push( @$array, $prefixRand);
	}	
}



# echo "./run_chicago.sh %2 res_hESC12_CHiCAGO2/ hESC12_CHiCAGO2
 # /bi/group/sysgen/RadaIglesias_data/ /bi/group/sysgen/RadaIglesias_data/features_hESC.txt
 # /bi/group/sysgen/hESC/sample_hESC811_new/hESC811_new_bait_otherEnd_N_len_distSign.txt
 # /bi/group/sysgen/hESC/sample_sample_1096_1390/sample_1096_1390_bait_otherEnd_N_len_distSign.txt" |
 # qsub -V -cwd -l vf=10G -pe orte 4 -o hESC_CHiC2.out -j y -N hESC_CHiC2 -m eas -M paulafp@babraham.ac.uk

#Launch pipeline step2
my %prefixStep2Files;    # %{prefix2} = array of filename(s) to process
my %prefixStep2Features;  # %{prefix2} = features file to process

#Create the new data structures
foreach my $array (@inputData){  
	my $prefixStep2 = $$array[2];
	my $file = $$array[0];
	my $features = $$array[3];
	
	push( @{ $prefixStep2Files{$prefixStep2} }, $file);
	$prefixStep2Features{$prefixStep2} = $features;
}



#print Dumper \%prefix2Files;
#print Dumper \%prefix2Features;

#Send step2 jobs to the cluster
foreach my $prefixStep2 (keys %prefixStep2Files){
	my $features = $prefixStep2Features{$prefixStep2};
	
	my @files = @{ $prefixStep2Files{$prefixStep2} };
	#@files = step1FileRenamer(@files);
	my $numberFiles = scalar @files;
	my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
	
	print "$features\n";
	$features =~ /(.+\/)/;
	my $featuresFolder = $1;
	print "$featuresFolder\n";
	
	
	
	if($numberFiles == 1){
		my $command ="$Bin/run_chicago2.sh $files[0] $outdir $featuresFolder $features"; 
		!system("$command") or die "Could not run '$command' : $!";		
		my $clusterCommand;
	}else{

	}
	
}
	
	
	
		
	







exit (0);

###########################################################################
#Subroutines
############################################################################

#Create a random letter string
#Takes a number for the length of
#the string and returns the string
sub generateRandomString{
	my $length = $_[0];
	
	my @chars = ("A".."Z", "a".."z");
	my $string;
	$string .= $chars[rand @chars] for 1..$length;
	
	return $string;
}






#Confirms that output directory, features file,
#data files baits and digest fragments exist
sub check_parameters{
	my $parameters_ok = 1;
	
	#Check baits specified
	unless( hasval($config{baits}) ){
		warn "Please specify a --baits file\n";
		$parameters_ok = 0;
	}
	
	#Check digest specified
	unless( hasval($config{digest}) ){
		warn "Please specify a --digest file\n";
		$parameters_ok = 0;
	}
	
	#Check baits exist
	if(hasval($config{baits}) ){
		unless(-e $config{baits}){
			warn "Baits file '$config{baits}' does not exist\n";
			$parameters_ok = 0;
		}
	}

	#Check digest exists
	if(hasval($config{digest}) ){
		unless(-e $config{digest}){
			warn "Digest file '$config{digest}' does not exist\n";
			$parameters_ok = 0;
		}
	}
	
	if(hasval ($config{input}) ){
		unless(-e $config{input}){
			warn "Input file '$config{input}' does not exist\n";
			$parameters_ok = 0;
		}
	}else{
		warn "Please specify an --input file\n";
		$parameters_ok = 0;		
	}
	
	if( hasval($config{email}) ){
		$config{email} = '-m eas -M ' . $config{email};
	}
	

	die "Please adjust configuration.\n" unless($parameters_ok);
}




#Subroutine: processInputfile
#Reads the inputfile and creates a datastructure
#Checks the data files exist
sub processInputfile{

	my $parameters_ok = 1;

	open(IN, '<', $config{input}) or die "Could not open '$config{input}' : $!";
	while(<IN>){
		my $line = $_;
		chomp $line;
		
		next if($line =~ /^\s*$/);
		
		my @lineArray = split(/\t/, $line);
		push(@inputData, [@lineArray]);
	
	
	}	
	close IN or die "Could not close $config{input}; : $!";
	
	#Check all input data files exit
	foreach my $array (@inputData){
		unless( -e $$array[0]){
			warn "Data file '$$array[0]' does not exist\n";
			$parameters_ok = 0;
		}	
	}
	
	#Check that all prefix1 entries are unique
	my %prefix1Count;
	foreach my $array (@inputData){
		if( hasval($$array[1]) ){
			$prefix1Count{$$array[1]}++;
		}	
	}
	foreach my $prefix1 (keys %prefix1Count){
		if($prefix1Count{$prefix1} > 1){
			warn "Prefix for step1 '$prefix1' appears $prefix1Count{$prefix1} times in the file '$config{input}'\n";
			$parameters_ok = 0;
		}
	}	
	
	
	#Check output directories don't already exist
	my %outputDirectories;
	my $alreadyExist = 0;
	foreach my $array (@inputData){
		my $step1Name = 'sample_' . $$array[1];
		my $step2Name = 'res_' . $$array[2];    #Check 'res' is output from CHiCAGO
	
		$outputDirectories{$step1Name} = '';    #Output folder name
		$outputDirectories{$step2Name} = '';    #Output folder name
	}
	
	foreach my $directory (keys %outputDirectories){
		$directory = $directory;
		if(-d $directory){
			warn "Output directory '$directory' already exists\n";
			$alreadyExist = 1;
		}
	}
	
	if($alreadyExist){
		my $reply = '';
		while( ($reply ne 'YES') and ($reply ne 'NO') ){
			warn "Do you want to overwrite the file in the output directories that alread exist [YES/NO]?\n";
			$reply = <STDIN>;
			chomp $reply;
			$reply = uc $reply;
		}
		
		if($reply eq 'NO'){
			$parameters_ok = 0;
		}
	
	}
	
	die "Please adjust configuration.\n" unless($parameters_ok);


}










############################
#Subroutine "process_config":
#Takes i) configuration file name and ii) %config hash (as a reference).
#The script then uses the configuration file to populate the hash as
#appropriate. Parameters passed via the command line take priority
#over those defined in the configuration file.
#The script modifies the hash directly, but returns as an array the lines in the configuration
#file that could did not correspond configuration parameters (these should be filenames).
sub process_config {
    my ( $config_file, $config_hash_ref ) = @_;
    my @non_parameters;    #Stores lines in the configuration file not defined as parameters

    #Open configuration file
    open( CONF, "$config_file" ) or die "Can't read $config_file: $!";

    while (<CONF>) {

        my $line = $_;
        chomp $line;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;    #Remove starting/trailing white spaces

        next if $line =~ /^\s*\#/;    #Ignore comments
        next if $line =~ /^\s*$/;     #Ignore whitespace


		
        #Check if this is a parameter
        my ( $parameter, $setting ) = split( /:/, $line );
        $parameter =~ s/^\s+//;
        $parameter =~ s/\s+$//;       #Remove starting/trailing white spaces
        $parameter = lc $parameter;
		$setting =~ s/^\s+// if defined ($setting);
        $setting =~ s/\s+$// if defined ($setting); 

        if ( exists $$config_hash_ref{$parameter} ) {
            if ( $$config_hash_ref{$parameter} eq '' ) {    #Check parameter not assigned value in command line
                $$config_hash_ref{$parameter} = $setting;    #Edit the configuration hash
            }
        } else {
            push( @non_parameters, $line );
        }
    }
    close CONF or die "Could not close filhandle on configuration file: '$config_file'\n";

    return @non_parameters;
}


###############################################################
#Sub: hasval
#Takes a string and returns true (i.e. '1') if the string has a value
#(i.e. is not equal to nothing (''). This is useful since some
#variables may be set to nothing allowing them to be evaluated
#without initialisation errors, while simultaneously containing
#no information.
sub hasval {
    if ( $_[0] ne '' ) {
        return 1;
    } else {
        return 0;
    }
}





__DATA__

The chicago Perl script controls the other programs in the CHiCAGO pipeline

SYNOPSIS

CHiCAGO [OPTIONS]... [Configuration FILE]...

FUNCTION



COMMAND LINE OPTIONS

--config         Specify the configuration file
--help	         Print program help and exit
--version        Print the program version and exit






