#!/usr/bin/perl

use strict;
use warnings;
use File::Basename;
use Getopt::Long;
use FindBin '$Bin';
use lib $Bin;
use File::Temp qw/ tempfile tempdir /;

use Data::Dumper;





##########################################################
#Get user-supplied parameters
#Option variables
my %config = (
	digestfolder => '',
	features => '',
	input => '',
	email => '',
	help => '',
	hold_jid => '',
	config => '',
	settings => '',
	matrix => ''
);

my $config_result = GetOptions(    #Stores parameters
	"digestfolder=s" => \$config{digestfolder},
	"features" =>	\$config{features},
	"input=s"   => \$config{input},
	"email=s"   => \$config{email},
	"help"   => \$config{help},
	"hold_jid=s" => \$config{hold_jid},
	"config=s"   => \$config{config},
    "settings=s" => \$config{settings},
    "matrix" => \$config{matrix} 
	);

die "Command line options need to be in the correct format (chicago -help for more details).\n" unless ($config_result);

my $baits;
my $digest;

my @inputData;    #Array of arrays storing the data from the input file

if ( $config{help} ) {
    print while (<DATA>);
    exit(0);
}

if( hasval($config{matrix}) ){    #Running the peak matrix only
	die "Please specify input files for generating a peak martix.\n" unless @ARGV;
	my @files = deduplicate_array(@ARGV);
	check_files_exist(\@files, 'EXISTS');
	print "Option --matrix selected, generating Peak Matrix only\n";
	open(LOG, '>', 'chicagoPeakMatrixLog.txt') or die "Could not write to 'chicagoPeakMatrixLog.txt' : $!";
	run_peak_matrix('MATRIX_ONLY', $config{email}, @files);
	close LOG or die "Could not close 'chicagoPeakMatrixLog.txt' : $!";
	print "Processing complete.";
	exit (0);
} 


if( hasval($config{config}) ) {
	process_config($config{config}, \%config)
}


check_parameters();
processInputfile();
  
    
#Create a log file
open(LOG, '>', 'chicagoLog.txt') or die "Could not write to 'chicagoLog.txt' : $!";
	
#Launch pipeline step1
foreach my $array (@inputData){
	if( hasval($$array[1]) ){    #Prefix 1 is present
		my $inputFile = $$array[0];
		my $prefix1 = $$array[1];
		my $prefixRand = "$prefix1." . generateRandomString(6);
		my $step1_jid_string = '';
		if(hasval ($config{hold_jid}) ){
			$step1_jid_string = "-hold_jid $config{hold_jid}";
		}		
		my $command = "$Bin/chicagoTools/bam2chicago.sh $inputFile $baits $digest $prefix1";
		my $clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=100G -o CHiCAGO1.$prefixRand.out -j y -N CHiCAGO1.$prefixRand $config{email} $step1_jid_string";
		
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";
		print LOG "CHiCAGO_Step1:\t$clusterCommand\n";
		push( @$array, "CHiCAGO1.$prefixRand");
	}	
}

#Launch pipeline step2
my %prefixStep2Files;    # %{prefix2} = array of filename(s) to process
my %prefixStep2Features;  # %{prefix2} = features file to process
my %jids4Step2;    # %{prefix2} = array of Step1 job ids   

#Create the new data structures
foreach my $array (@inputData){  
	my $prefixStep1 = $$array[1];
	my $prefixStep2 = $$array[2];
	my $file = $$array[0];
	my $jid = $$array[4];
	
	if(hasval($prefixStep1) ){
		$file = calcStep1Outfile($prefixStep1);
		push( @{ $jids4Step2{$prefixStep2} }, $jid); 
	}
	
	my $features = $$array[3];
	push( @{ $prefixStep2Files{$prefixStep2} }, $file);
	$prefixStep2Features{$prefixStep2} = $features;
}


#Send step2 jobs to the cluster
my @submittedStep2Jobs;   #Stores the names of jobs submitted to the cluster in order. Even sent to node 0, odd to node 1

if($config{features}){

	#Check prefix2 all unique
	my $parameters_ok = 1;
	foreach my $prefixStep2 (keys %prefixStep2Files){
		my @files = @{ $prefixStep2Files{$prefixStep2} };
		my $numberFiles = scalar @files;

		if($numberFiles != 1){
			warn "Duplicate prefix2: $prefixStep2\n";
			$parameters_ok = 0;
		}
	}
	die "When running --features, all prefix 2 entries need to be different.\n" unless ($parameters_ok);
	
	
	#Send jobs to cluster
	foreach my $prefixStep2 (keys %prefixStep2Files){
		my $features = $prefixStep2Features{$prefixStep2};
		
		my @files = @{ $prefixStep2Files{$prefixStep2} };

		my $numberFiles = scalar @files;
		my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
		

		$features =~ /(.+\/)/;
		my $featuresFolder = $1;
		
		#Calculate jids (if necessary)
		my @jids;
		my $step2_jid_string = '';    #Jobs to wait for as defined by the user
		if(exists $jids4Step2{$prefixStep2} ){
			@jids = @{ $jids4Step2{$prefixStep2} };
			$step2_jid_string = join(',', @jids);
		}
		if(hasval ($config{hold_jid}) ){
			$step2_jid_string = $step2_jid_string . ',' . $config{hold_jid};
		}	
		if(hasval ($step2_jid_string) ){
			$step2_jid_string = "-hold_jid $step2_jid_string";
		}
		

		my $params = "--features-only --en-feat-folder $featuresFolder --en-feat-list $features";
		my $command = "Rscript $Bin/chicagoTools/runChicago.R $params $files[0] $prefixStep2";		

			my $prefix2Rand = basename($prefixStep2) . generateRandomString(6);    #To remove forward slashes in the job name (-N)				
			my $currentJobName = "CHiCAGO2.$prefix2Rand";
			push (@submittedStep2Jobs, $currentJobName);
			my $jobSent = scalar @submittedStep2Jobs;
			my $clusterCommand;	
						
			$clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=50G -o $prefix2Rand.out -j y -N $currentJobName $config{email} $step2_jid_string";	
					
			print LOG "CHiCAGO_Step2:\t$clusterCommand\n";	
			!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";	
	}
	
}else{

	foreach my $prefixStep2 (keys %prefixStep2Files){
		my $features = $prefixStep2Features{$prefixStep2};
		
		my @files = @{ $prefixStep2Files{$prefixStep2} };
		#@files = step1FileRenamer(@files);
		my $numberFiles = scalar @files;
		my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
		
		$features =~ /(.+\/)/;
		my $featuresFolder = $1;
		
		#Calculate jids (if necessary)
		my @jids;
		my $step2_jid_string = '';    #Jobs to wait for as defined by the user
		if(exists $jids4Step2{$prefixStep2} ){
			@jids = @{ $jids4Step2{$prefixStep2} };
			$step2_jid_string = join(',', @jids);
		}
		if(hasval ($config{hold_jid}) ){
			$step2_jid_string = $step2_jid_string . ',' . $config{hold_jid};
		}	
		if(hasval ($step2_jid_string) ){
			$step2_jid_string = "-hold_jid $step2_jid_string";
		}
		my $memory_allocation;
		if($numberFiles == 1){
			$memory_allocation = 'h_vmem=100G';
		}else{	
			my $mem = $numberFiles * 75;
			if ($mem > 400) {
				print "Capping memory allocation to 400Gb\n";
				$mem = 400;
			}
			$memory_allocation = 'h_vmem='.$mem.'G';

		}
		print "Requesting memory allocation: $memory_allocation\n";
		
		my $command;
		my $params = "--output-dir $outdir --en-feat-folder $featuresFolder --en-feat-list $features --design-dir $config{digestfolder} --export-format seqMonk,washU_text";
		if (hasval($config{settings})){
			$params .= " --settings-file $config{settings}";
		}

		if($numberFiles == 1){
			$command = "Rscript $Bin/chicagoTools/runChicago.R $params $files[0] $prefixStep2";		
		
		}else{
			my $filenameString = join(',', @files);
			$command = "Rscript $Bin/chicagoTools/runChicago.R $params $filenameString $prefixStep2";			
		}
			
			my $prefix2Rand = basename($prefixStep2) . generateRandomString(6);    #To remove forward slashes in the job name (-N)				
			my $currentJobName = "CHiCAGO2.$prefix2Rand";
			push (@submittedStep2Jobs, $currentJobName);
			my $jobSent = scalar @submittedStep2Jobs;
			my $clusterCommand;	
			$clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l $memory_allocation -o $prefix2Rand.out -j y -N $currentJobName $config{email} $step2_jid_string";	
					
			print LOG "CHiCAGO_Step2:\t$clusterCommand\n";	
			!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";	
	}
}

run_peak_matrix('CALCULATE_INPUTFILES', \%prefixStep2Files, \@submittedStep2Jobs, \%config);
		
close LOG or die "Could not close 'chicagoLog.txt' : $!";

print "Processing complete.\n";	
	
exit (0);



###########################################################################
#Subroutines
############################################################################
	
#Create Peak matrix	
sub run_peak_matrix{
	my $options = $_[0];
	
	#Create a peak matrix file for the R script to read
    my ($conf_fh, $conf_filename) = tempfile( 'peak_matrix_input.XXXXXXXX', SUFFIX => '.txt' );
	my $hold_jid_string = '';
	my $email = '';
	
	
	if($options eq 'MATRIX_ONLY'){
		my @files = @_;
		shift @files;    #Remove options variable
		my $email = shift @files;  
	
		foreach my $file (@files){
			my $name = $file; 
			$name =~ s/\.RDa//;
			print $conf_fh "$name\t$file\n"; 
		}
	
	}elsif($options eq 'CALCULATE_INPUTFILES'){
	
		my (undef, $prefixStep2Files_hash_ref, $hold_jid_ref, $config_hash_ref) = @_;
			
		foreach my $prefix ( keys %{ $prefixStep2Files_hash_ref } ){
			my $step2_outfile = 'res_' . $prefix . '_chicago2/data/' . "$prefix.RDa";
			print $conf_fh "$prefix\t$step2_outfile\n"; 
		
		}
		
		$hold_jid_string = join(',', @$hold_jid_ref);
		$hold_jid_string = '-hold_jid ' . $hold_jid_string;
		$email = $$config_hash_ref{email};
		
	}else{
		die "Subroutine 'run_peak_matrix' passed invalid options parameter: '$options'\n";
	}
	close $conf_fh or die "Could not close '$conf_filename' : $!";
	
	
	#Send the job to the cluster
	my $random_string = generateRandomString(6);
	my $outfile = "Peak_Matrix.CHiCAGO.$random_string";
	my $jobname = $outfile;

	
	my $command = "Rscript $Bin/chicagoTools/makePeakMatrix.R --twopass $conf_filename $outfile";
	my $clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=200G -o $jobname.out -j y -N $jobname $email $hold_jid_string";	
	print LOG "$clusterCommand\n";
	!system($clusterCommand) or die "Could not generate Peak Matrix: '$clusterCommand'\n";
	#unlink $conf_filename or warn "Could not delete $conf_filename\n";   - Don't delete this file, else file will be deleted before cluster job starts
}	
	


#Takes the prefix for Step 1 and calculates the path and name of the
#file produced by CHiCAGO step1
sub calcStep1Outfile{
	my $prefix = $_[0];
	my $outFile = $prefix . '/' . $prefix . '.chinput';
	return $outFile;
}



#Create a random letter string
#Takes a number for the length of
#the string and returns the string
sub generateRandomString{
	my $length = $_[0];
	
	my @chars = ("A".."Z", "a".."z");
	my $string;
	$string .= $chars[rand @chars] for 1..$length;
	
	return $string;
}



#Confirms that output directory, features file,
#data files baits and digest fragments exist
sub check_parameters{
	my $parameters_ok = 1;
	
	#Add path to digest and bait filenames
	if( hasval ($config{digestfolder}) ){	
		$config{digestfolder} = $config{digestfolder} . '/' unless $config{digestfolder} =~ /\/$/;
	}else{
		$config{digestfolder} = './';
		warn "Using current working directory as digest folder\n";
	}
	
	#Check baits exist
	if (!defined($baits)){ $baits = "" };
	unless(-e $baits){
			opendir(DIR, $config{digestfolder}) || die ("Could not open digest dir $config{digestfolder}");
			my @baitmapfiles = grep(/\.baitmap$/,readdir(DIR));
			closedir(DIR);
			if(scalar(@baitmapfiles)==1){
				warn "Found baits file $baitmapfiles[0] in $config{digestfolder}\n";
				$baits = $config{digestfolder} . '/' . $baitmapfiles[0];
			}
			else{
				warn "Baits file '$baits' does not exist\n";
				$parameters_ok = 0;
			}
	}

	#Check digest exists
	if (!defined($digest)){ $digest = "" };
	unless(-e $digest){
			opendir(DIR, $config{digestfolder}) || die ("Could not open digest dir $config{digestfolder}");;
			my @digestfiles = grep(/\.rmap$/,readdir(DIR));
			closedir(DIR);
			if(scalar(@digestfiles)==1){
				warn "Found digest file $digestfiles[0] in $config{digestfolder}\n";
				$digest = $config{digestfolder} . '/' . $digestfiles[0];
			}
			else{
				warn "Digest file '$digest' does not exist\n";
				$parameters_ok = 0;
			}
	}
	
	if(hasval ($config{input}) ){
		unless(-e $config{input}){
			warn "Input file '$config{input}' does not exist\n";
			$parameters_ok = 0;
		}
	}else{
		warn "Please specify an --input file\n";
		$parameters_ok = 0;		
	}
	
	if( hasval($config{email}) ){
		$config{email} = '-m eas -M ' . $config{email};
	}
	
	if( hasval($config{hold_jid}) ){
		my @hold_jid = split(/,/, $config{hold_jid});
		foreach my $jid (@hold_jid){
			unless($jid =~ /^\d+$/){
				warn "The --hold_jid parameter '$jid' needs to be an integer\n";
				$parameters_ok = 0;
			}	
		}
		$config{hold_jid} = join(',', @hold_jid);    #Better to use this than original (may contain ',,' etc.)
	}
	die "Please adjust configuration.\n" unless($parameters_ok);
}




#Subroutine: processInputfile
#Reads the inputfile and creates a datastructure
#Checks the data files exist
sub processInputfile{

	my $parameters_ok = 1;

	open(IN, '<', $config{input}) or die "Could not open '$config{input}' : $!";
	while(<IN>){
		my $line = $_;
		chomp $line;
		
		next if($line =~ /^\s*$/);
		
		my @lineArray = split(/\t/, $line);
		push(@inputData, [@lineArray]);
	
	
	}	
	close IN or die "Could not close $config{input}; : $!";
	
	#Check all input data files exit
	foreach my $array (@inputData){
		unless( -e $$array[0]){
			warn "Data file '$$array[0]' does not exist\n";
			$parameters_ok = 0;
		}	
	}
	
	#Check that all prefix1 entries are unique
	my %prefix1Count;
	foreach my $array (@inputData){
		if( hasval($$array[1]) ){
			$prefix1Count{$$array[1]}++;
		}	
	}
	foreach my $prefix1 (keys %prefix1Count){
		if($prefix1Count{$prefix1} > 1){
			warn "Prefix for step1 '$prefix1' appears $prefix1Count{$prefix1} times in the file '$config{input}'\n";
			$parameters_ok = 0;
		}
	}	
	
	
	#Check output directories don't already exist
	my %outputDirectories;
	my $alreadyExist = 0;
	foreach my $array (@inputData){
		my $step1Name = 'sample_' . $$array[1];
		my $step2Name = 'res_' . $$array[2];    #Check 'res' is output from CHiCAGO
	
		$outputDirectories{$step1Name} = '';    #Output folder name
		$outputDirectories{$step2Name} = '';    #Output folder name
	}
	
	foreach my $directory (keys %outputDirectories){
		$directory = $directory;
		if(-d $directory){
			warn "Output directory '$directory' already exists\n";
			$alreadyExist = 1;
		}
	}
	
	if($alreadyExist){
		my $reply = '';
		while( ($reply ne 'YES') and ($reply ne 'NO') ){
			warn "Do you want to overwrite the file in the output directories that alread exist [YES/NO]?\n";
			$reply = <STDIN>;
			chomp $reply;
			$reply = uc $reply;
		}
		
		if($reply eq 'NO'){
			$parameters_ok = 0;
		}
	
	}
	
	die "Please adjust configuration.\n" unless($parameters_ok);

}



############################
#Subroutine "process_config":
#Takes i) configuration file name and ii) %config hash (as a reference).
#The script then uses the configuration file to populate the hash as
#appropriate. Parameters passed via the command line take priority
#over those defined in the configuration file.
#The script modifies the hash directly, but returns as an array the lines in the configuration
#file that could did not correspond configuration parameters (these should be filenames).
sub process_config {
    my ( $config_file, $config_hash_ref ) = @_;
    my @non_parameters;    #Stores lines in the configuration file not defined as parameters

    #Open configuration file
    open( CONF, "$config_file" ) or die "Can't read $config_file: $!";

    while (<CONF>) {

        my $line = $_;
        chomp $line;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;    #Remove starting/trailing white spaces

        next if $line =~ /^\s*\#/;    #Ignore comments
        next if $line =~ /^\s*$/;     #Ignore whitespace
	
        #Check if this is a parameter
        my ( $parameter, $setting ) = split( /:/, $line );
        $parameter =~ s/^\s+//;
        $parameter =~ s/\s+$//;       #Remove starting/trailing white spaces
        $parameter = lc $parameter;
		$setting =~ s/^\s+// if defined ($setting);
        $setting =~ s/\s+$// if defined ($setting); 

		print "$parameter\t$setting\t\n";
		
        if ( exists $$config_hash_ref{$parameter} ) {
            if ( $$config_hash_ref{$parameter} eq '' ) {    #Check parameter not assigned value in command line
                $$config_hash_ref{$parameter} = $setting;    #Edit the configuration hash
            }
        } else {
            push( @non_parameters, $line );
        }
    }
    close CONF or die "Could not close filhandle on configuration file: '$config_file'\n";

    return @non_parameters;
}



###############################################################
#Sub: hasval
#Takes a string and returns true (i.e. '1') if the string has a value
#(i.e. is not equal to nothing (''). This is useful since some
#variables may be set to nothing allowing them to be evaluated
#without initialisation errors, while simultaneously containing
#no information.
sub hasval {
    if ( $_[0] ne '' ) {
        return 1;
    } else {
        return 0;
    }
}





##########################################
#Subroutine: check_files_exist
#Takes a reference to an array containing paths to filenames and verifies they exist
#Warns of files that do no exit. Returns 1 if all files exist but 0 if this is not
#the case.
#
#Also, takes a second argument:
#$_[1] should be 'EXISTS' or 'NOT_EXISTS'
#If 'NOT_EXISTS' warns if file already exists.  Returns '1' if none of the
#files exists and '0' if one or multiple files already exist
sub check_files_exist {
    my $files      = $_[0];    #Reference to array
    my $check_for  = $_[1];
    my $all_exist  = 1;
    my $not_exists = 1;

    if ( $check_for eq 'EXISTS' ) {
        foreach my $file (@$files) {
            unless ( -e $file ) {
                warn "File '$file' does not exist\n";
                $all_exist = 0;
            }
        }
    } elsif ( $check_for eq 'NOT_EXISTS' ) {
        foreach my $file (@$files) {
            if ( -e $file ) {
                warn "File '$file' already exists\n";
                $not_exists = 0;
            }
        }
    } else {
        die "Subroutine 'check_files_exist' requires argument 'EXISTS' or 'NOT_EXISTS'.\n";
    }

    if ( $check_for eq 'EXISTS' ) {
        return $all_exist;
    } else {
        return $not_exists;
    }
}


##########################################
#Subroutine: deduplicate_array
#Takes and array and returns the array with duplicates removed
#(keeping 1 copy of each unique entry).
sub deduplicate_array {
    my @array = @_;
    my %uniques;

    foreach (@array) {
        $uniques{$_} = '';
    }
    my @uniques_array = keys %uniques;
    return @uniques_array;
}


__DATA__

The chicago Perl script controls the other programs in the CHiCAGO pipeline

SYNOPSIS

CHiCAGO [OPTIONS]... [Configuration FILE]...

FUNCTION

TODO

COMMAND LINE OPTIONS

--config              	Specify the configuration file
--features       		Process the features enrichment plots only
--help	              	Print program help and exit
--hold_jid            	Place jobs on hold until specified cluster jobs have completed
--version             	Print the program version and exit






