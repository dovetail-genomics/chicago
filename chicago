#!/usr/bin/perl

use strict;
use warnings;
use File::Basename;
use Getopt::Long;
use FindBin '$Bin';
use lib $Bin;

use Data::Dumper;


##########################################################
#Get user-supplied parameters
#Option variables
my %config = (
	digestfolder => '',
	input => '',
	email => '',
	help => '',
	hold_jid => '',
	config => '',
	settings => ''
);

my $config_result = GetOptions(    #Stores parameters
	"digestfolder=s" => \$config{digestfolder},
	"input=s"   => \$config{input},
	"email=s"   => \$config{email},
	"help"   => \$config{help},
	"hold_jid=s" => \$config{hold_jid},
	"config=s"   => \$config{config},
        "settings=s" => \$config{settings}
	);

die "Command line options need to be in the correct format (chicago -help for more details).\n" unless ($config_result);

my $baits;
my $digest;

my @inputData;    #Array of arrays storing the data from the input file

if ( $config{help} ) {
    print while (<DATA>);
    exit(0);
}

if( hasval($config{config}) ) {
	process_config($config{config}, \%config)
}

#print Dumper \%config;

check_parameters();
processInputfile();
  
#Create a log file
open(LOG, '>', 'chicagoLog.txt') or die "Could not write to 'chicagoLog.txt' : $!";
	
#Launch pipeline step1
foreach my $array (@inputData){
	if( hasval($$array[1]) ){    #Prefix 1 is present
		my $inputFile = $$array[0];
		my $prefix1 = $$array[1];
		my $prefixRand = "$prefix1." . generateRandomString(6);
		my $step1_jid_string = '';
		if(hasval ($config{hold_jid}) ){
			$step1_jid_string = "-hold_jid $config{hold_jid}";
		}		
		my $command = "$Bin/bam2chicago.sh $inputFile $baits $digest $prefix1";
		my $clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=200G -pe cores 4 -o CHiCAGO1.$prefixRand.out -j y -N CHiCAGO1.$prefixRand $config{email} $step1_jid_string";
		
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";
		print LOG "CHiCAGO_Step1:\t$clusterCommand\n";
		push( @$array, "CHiCAGO1.$prefixRand");
	}	
}

#Launch pipeline step2
my %prefixStep2Files;    # %{prefix2} = array of filename(s) to process
my %prefixStep2Features;  # %{prefix2} = features file to process
my %jids4Step2;    # %{prefix2} = array of Step1 job ids   

#Create the new data structures
foreach my $array (@inputData){  
	my $prefixStep1 = $$array[1];
	my $prefixStep2 = $$array[2];
	my $file = $$array[0];
	my $jid = $$array[4];
	
	if(hasval($prefixStep1) ){
		$file = calcStep1Outfile($prefixStep1);
		push( @{ $jids4Step2{$prefixStep2} }, $jid); 
	}
	
	my $features = $$array[3];
	push( @{ $prefixStep2Files{$prefixStep2} }, $file);
	$prefixStep2Features{$prefixStep2} = $features;
}

#print Dumper \%prefix2Files;
#print Dumper \%prefix2Features;

#Send step2 jobs to the cluster
my @submittedStep2Jobs;   #Stores the names of jobs submitted to the cluster in order. Even sent to node 0, odd to node 1

foreach my $prefixStep2 (keys %prefixStep2Files){
	my $features = $prefixStep2Features{$prefixStep2};
	
	my @files = @{ $prefixStep2Files{$prefixStep2} };
	#@files = step1FileRenamer(@files);
	my $numberFiles = scalar @files;
	my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
	

	$features =~ /(.+\/)/;
	my $featuresFolder = $1;
	
	#Calculate jids (if necessary)
	my @jids;
	my $step2_jid_string = '';    #Jobs to wait for as defined by the user
	if(exists $jids4Step2{$prefixStep2} ){
		@jids = @{ $jids4Step2{$prefixStep2} };
		$step2_jid_string = join(',', @jids);
	}
	if(hasval ($config{hold_jid}) ){
		$step2_jid_string = $step2_jid_string . ',' . $config{hold_jid};
	}	
	if(hasval ($step2_jid_string) ){
		$step2_jid_string = "-hold_jid $step2_jid_string";
	}
	
	
	my $command;

	my $params = "--output-dir $outdir --en-feat-folder $featuresFolder --en-feat-list $features --design-dir $config{digestfolder}";
	if (hasval($config{settings})){
		$params .= " --settings-file $config{settings}";
	}

	if($numberFiles == 1){
		$command = "Rscript $Bin/runChicago.R $params $files[0] $prefixStep2";		
	
	}else{
		my $filenameString = join(',', @files);
		$command = "Rscript $Bin/runChicago.R $params $filenameString $prefixStep2";			
	}
		my $prefix2Rand = "$prefixStep2." . generateRandomString(6);
		
		my $currentJobName = "CHiCAGO2.$prefix2Rand";
		push (@submittedStep2Jobs, $currentJobName);
		my $jobSent = scalar @submittedStep2Jobs;
		my $clusterCommand;	
			
		# if($jobSent > 4){
			# my $jobToWaitFor = $submittedStep2Jobs[$jobSent - 5];
			# if($jid_string eq ''){
				# $jid_string = '-hold_jid '; 
			# }
			# $jid_string = $jid_string . ',' . $jobToWaitFor;
			# $jid_string =~ s/hold_jid ,/hold_jid /;
		# }	
		
		my $memory_allocation;
		if($numberFiles == 1){
			$memory_allocation = 'h_vmem=300G';
		}else{
			$memory_allocation = 'h_vmem=500G';
		}
		
		$clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l $memory_allocation -pe cores 4 -o $prefix2Rand.out -j y -N $currentJobName $config{email} $step2_jid_string";	
	
		#print "$clusterCommand\n";
	#	print "$command\n";
		
	#	!system("$command") or die "Could not run '$command' : $!";
		
		print LOG "CHiCAGO_Step2:\t$clusterCommand\n";	
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";	

}
		
close LOG or die "Could not close 'chicagoLog.txt' : $!";

print "Processing complete.\n";	

#print Dumper \%config;
	
exit (0);



###########################################################################
#Subroutines
############################################################################

#Takes the prefix for Step 1 and calculates the path and name of the
#file produced by CHiCAGO step1
sub calcStep1Outfile{
	my $prefix = $_[0];
	my $outFile = $prefix . '/' . $prefix . '.chinput';
	return $outFile;
}



#Create a random letter string
#Takes a number for the length of
#the string and returns the string
sub generateRandomString{
	my $length = $_[0];
	
	my @chars = ("A".."Z", "a".."z");
	my $string;
	$string .= $chars[rand @chars] for 1..$length;
	
	return $string;
}



#Confirms that output directory, features file,
#data files baits and digest fragments exist
sub check_parameters{
	my $parameters_ok = 1;
	
	#Add path to digest and bait filenames
	if( hasval ($config{digestfolder}) ){	
		$config{digestfolder} = $config{digestfolder} . '/' unless $config{digestfolder} =~ /\/$/;
	}else{
		$config{digestfolder} = './';
		warn "Using current working directory as digest folder\n";
	}
	
	#Check baits exist
	if (!defined($baits)){ $baits = "" };
	unless(-e $baits){
			opendir(DIR, $config{digestfolder}) || die ("Could not open digest dir $config{digestfolder}");
			my @baitmapfiles = grep(/\.baitmap$/,readdir(DIR));
			closedir(DIR);
			if(scalar(@baitmapfiles)==1){
				warn "Found baits file $baitmapfiles[0] in $config{digestfolder}\n";
				$baits = $config{digestfolder} . '/' . $baitmapfiles[0];
			}
			else{
				warn "Baits file '$baits' does not exist\n";
				$parameters_ok = 0;
			}
	}

	#Check digest exists
	if (!defined($digest)){ $digest = "" };
	unless(-e $digest){
			opendir(DIR, $config{digestfolder}) || die ("Could not open digest dir $config{digestfolder}");;
			my @digestfiles = grep(/\.rmap$/,readdir(DIR));
			closedir(DIR);
			if(scalar(@digestfiles)==1){
				warn "Found digest file $digestfiles[0] in $config{digestfolder}\n";
				$digest = $config{digestfolder} . '/' . $digestfiles[0];
			}
			else{
				warn "Digest file '$digest' does not exist\n";
				$parameters_ok = 0;
			}
	}
	
	if(hasval ($config{input}) ){
		unless(-e $config{input}){
			warn "Input file '$config{input}' does not exist\n";
			$parameters_ok = 0;
		}
	}else{
		warn "Please specify an --input file\n";
		$parameters_ok = 0;		
	}
	
	if( hasval($config{email}) ){
		$config{email} = '-m eas -M ' . $config{email};
	}
	
	if( hasval($config{hold_jid}) ){
		my @hold_jid = split(/,/, $config{hold_jid});
		foreach my $jid (@hold_jid){
			unless($jid =~ /^\d+$/){
				warn "The --hold_jid parameter '$jid' needs to be an integer\n";
				$parameters_ok = 0;
			}	
		}
		$config{hold_jid} = join(',', @hold_jid);    #Better to use this than original (may contain ',,' etc.)
	}
	die "Please adjust configuration.\n" unless($parameters_ok);
}




#Subroutine: processInputfile
#Reads the inputfile and creates a datastructure
#Checks the data files exist
sub processInputfile{

	my $parameters_ok = 1;

	open(IN, '<', $config{input}) or die "Could not open '$config{input}' : $!";
	while(<IN>){
		my $line = $_;
		chomp $line;
		
		next if($line =~ /^\s*$/);
		
		my @lineArray = split(/\t/, $line);
		push(@inputData, [@lineArray]);
	
	
	}	
	close IN or die "Could not close $config{input}; : $!";
	
	#Check all input data files exit
	foreach my $array (@inputData){
		unless( -e $$array[0]){
			warn "Data file '$$array[0]' does not exist\n";
			$parameters_ok = 0;
		}	
	}
	
	#Check that all prefix1 entries are unique
	my %prefix1Count;
	foreach my $array (@inputData){
		if( hasval($$array[1]) ){
			$prefix1Count{$$array[1]}++;
		}	
	}
	foreach my $prefix1 (keys %prefix1Count){
		if($prefix1Count{$prefix1} > 1){
			warn "Prefix for step1 '$prefix1' appears $prefix1Count{$prefix1} times in the file '$config{input}'\n";
			$parameters_ok = 0;
		}
	}	
	
	
	#Check output directories don't already exist
	my %outputDirectories;
	my $alreadyExist = 0;
	foreach my $array (@inputData){
		my $step1Name = 'sample_' . $$array[1];
		my $step2Name = 'res_' . $$array[2];    #Check 'res' is output from CHiCAGO
	
		$outputDirectories{$step1Name} = '';    #Output folder name
		$outputDirectories{$step2Name} = '';    #Output folder name
	}
	
	foreach my $directory (keys %outputDirectories){
		$directory = $directory;
		if(-d $directory){
			warn "Output directory '$directory' already exists\n";
			$alreadyExist = 1;
		}
	}
	
	if($alreadyExist){
		my $reply = '';
		while( ($reply ne 'YES') and ($reply ne 'NO') ){
			warn "Do you want to overwrite the file in the output directories that alread exist [YES/NO]?\n";
			$reply = <STDIN>;
			chomp $reply;
			$reply = uc $reply;
		}
		
		if($reply eq 'NO'){
			$parameters_ok = 0;
		}
	
	}
	
	die "Please adjust configuration.\n" unless($parameters_ok);

}



############################
#Subroutine "process_config":
#Takes i) configuration file name and ii) %config hash (as a reference).
#The script then uses the configuration file to populate the hash as
#appropriate. Parameters passed via the command line take priority
#over those defined in the configuration file.
#The script modifies the hash directly, but returns as an array the lines in the configuration
#file that could did not correspond configuration parameters (these should be filenames).
sub process_config {
    my ( $config_file, $config_hash_ref ) = @_;
    my @non_parameters;    #Stores lines in the configuration file not defined as parameters

    #Open configuration file
    open( CONF, "$config_file" ) or die "Can't read $config_file: $!";

    while (<CONF>) {

        my $line = $_;
        chomp $line;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;    #Remove starting/trailing white spaces

        next if $line =~ /^\s*\#/;    #Ignore comments
        next if $line =~ /^\s*$/;     #Ignore whitespace
	
        #Check if this is a parameter
        my ( $parameter, $setting ) = split( /:/, $line );
        $parameter =~ s/^\s+//;
        $parameter =~ s/\s+$//;       #Remove starting/trailing white spaces
        $parameter = lc $parameter;
		$setting =~ s/^\s+// if defined ($setting);
        $setting =~ s/\s+$// if defined ($setting); 

		print "$parameter\t$setting\t\n";
		
        if ( exists $$config_hash_ref{$parameter} ) {
            if ( $$config_hash_ref{$parameter} eq '' ) {    #Check parameter not assigned value in command line
                $$config_hash_ref{$parameter} = $setting;    #Edit the configuration hash
            }
        } else {
            push( @non_parameters, $line );
        }
    }
    close CONF or die "Could not close filhandle on configuration file: '$config_file'\n";

    return @non_parameters;
}



###############################################################
#Sub: hasval
#Takes a string and returns true (i.e. '1') if the string has a value
#(i.e. is not equal to nothing (''). This is useful since some
#variables may be set to nothing allowing them to be evaluated
#without initialisation errors, while simultaneously containing
#no information.
sub hasval {
    if ( $_[0] ne '' ) {
        return 1;
    } else {
        return 0;
    }
}



__DATA__

The chicago Perl script controls the other programs in the CHiCAGO pipeline

SYNOPSIS

CHiCAGO [OPTIONS]... [Configuration FILE]...

FUNCTION

TODO

COMMAND LINE OPTIONS

--config         Specify the configuration file
--help	         Print program help and exit
--hold_jid       Place jobs on hold until specified cluster jobs have completed
--version        Print the program version and exit






