#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use FindBin '$Bin';
use lib $Bin;

use Data::Dumper;




##########################################################
#Get user-supplied parameters
#Option variables
my %config = (
	basename => '',
	digestfolder => '',
	input => '',
	email => '',
	help => '',
	config => '',
	
);

my $config_result = GetOptions(    #Stores parameters
    "basename=s"  => \$config{basename},
	"digestfolder=s" => \$config{digestfolder},
    "input=s"   => \$config{input},
	"email=s"   => \$config{email},
	"help"   => \$config{help},
	"config=s"   => \$config{config}
	);

die "Command line options need to be in the correct format (chicago -help for more details).\n" unless ($config_result);

my $baits;
my $digest;

my @inputData;    #Array of arrays storing the data from the input file


if ( $config{help} ) {
    print while (<DATA>);
    exit(0);
}

if( hasval($config{config}) ) {
	process_config($config{config}, \%config)
}

#print Dumper \%config;

check_parameters();
processInputfile();

# echo "/bi/home/paulafp/CHiCAGOv2/process_chic_single_core.sh
 # sample1742_lane2174_L006_uniques_captured.bam
  # /bi/group/sysgen/CHIC/Digest_Human_HindIII_baits.bed 
  # /bi/group/sysgen/CHIC/Digest_Human_HindIII.bed sample1742"| 
  # qsub -V -cwd -l vf=10G -pe orte 4 -o sample1742.out -j y -N sample1742 -m eas -M paulafp@babraham.ac.uk

  
#Create a log file
open(LOG, '>', 'chicagoLog.txt') or die "Could not write to 'chicagoLog.txt' : $!";
	


  
  
  
#Launch pipeline step1
foreach my $array (@inputData){
	if( hasval($$array[1]) ){    #Prefix 1 is present
		my $inputFile = $$array[0];
		my $prefix1 = $$array[1];
		my $prefixRand = "$prefix1." . generateRandomString(6);
		my $command = "$Bin/process_chic_single_core.sh $inputFile $baits $digest $prefix1";
		my $clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l h_vmem=100G -pe cores 4 -o CHiCAGO1.$prefixRand.out -j y -N CHiCAGO1.$prefixRand $config{email}";
		
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";
		print LOG "CHiCAGO_Step1:\t$clusterCommand\n";
		push( @$array, "CHiCAGO1.$prefixRand");
	}	
}



# echo "./run_chicago.sh %2 res_hESC12_CHiCAGO2/ hESC12_CHiCAGO2
 # /bi/group/sysgen/RadaIglesias_data/ /bi/group/sysgen/RadaIglesias_data/features_hESC.txt
 # /bi/group/sysgen/hESC/sample_hESC811_new/hESC811_new_bait_otherEnd_N_len_distSign.txt
 # /bi/group/sysgen/hESC/sample_sample_1096_1390/sample_1096_1390_bait_otherEnd_N_len_distSign.txt" |
 # qsub -V -cwd -l vf=10G -pe orte 4 -o hESC_CHiC2.out -j y -N hESC_CHiC2 -m eas -M paulafp@babraham.ac.uk

#Launch pipeline step2
my %prefixStep2Files;    # %{prefix2} = array of filename(s) to process
my %prefixStep2Features;  # %{prefix2} = features file to process
my %jids4Step2;    # %{prefix2} = array of Step1 job ids   

#Create the new data structures
foreach my $array (@inputData){  
	my $prefixStep1 = $$array[1];
	my $prefixStep2 = $$array[2];
	my $file = $$array[0];
	my $jid = $$array[4];
	
	if(hasval($prefixStep1) ){
		$file = calcStep1Outfile($prefixStep1);
		push( @{ $jids4Step2{$prefixStep2} }, $jid); 
	}
	
	
	my $features = $$array[3];

	
	push( @{ $prefixStep2Files{$prefixStep2} }, $file);
	$prefixStep2Features{$prefixStep2} = $features;
}



#print Dumper \%prefix2Files;
#print Dumper \%prefix2Features;

#Send step2 jobs to the cluster
my @submittedStep2Jobs;   #Stores the names of jobs submitted to the cluster in order. Even sent to node 0, odd to node 1

foreach my $prefixStep2 (keys %prefixStep2Files){
	my $features = $prefixStep2Features{$prefixStep2};
	
	my @files = @{ $prefixStep2Files{$prefixStep2} };
	#@files = step1FileRenamer(@files);
	my $numberFiles = scalar @files;
	my $outdir = 'res_' . $prefixStep2 . '_chicago2/';
	

	$features =~ /(.+\/)/;
	my $featuresFolder = $1;
	
	#Calculate jids (if necessary)
	my @jids;
	my $jid_string;
	if(exists $jids4Step2{$prefixStep2} ){
		@jids = @{ $jids4Step2{$prefixStep2} };
		$jid_string = join(',', @jids);
		$jid_string = '-hold_jid ' . $jid_string;
	}else{
		$jid_string = '';
	}

	my $command;
	if($numberFiles == 1){
		$command = "R --slave --no-restore-data --args $files[0] $outdir $prefixStep2 $featuresFolder $features  $config{digestfolder} $config{basename} < $Bin/production_line_CHiCAGO2.R";		
	
	}else{
		my $filenameString = join(' ', @files);
		$command = "R --slave --no-restore-data --args  \%$numberFiles $outdir $prefixStep2 $featuresFolder $features $filenameString $config{digestfolder} $config{basename} < $Bin/production_line_CHiCAGO2.R";			
	}
		my $prefix2Rand = "$prefixStep2." . generateRandomString(6);
		
		my $currentJobName = "CHiCAGO2.$prefix2Rand";
		push (@submittedStep2Jobs, $currentJobName);
		my $jobSent = scalar @submittedStep2Jobs;
		my $clusterCommand;	
			
		# if($jobSent > 4){
			# my $jobToWaitFor = $submittedStep2Jobs[$jobSent - 5];
			# if($jid_string eq ''){
				# $jid_string = '-hold_jid '; 
			# }
			# $jid_string = $jid_string . ',' . $jobToWaitFor;
			# $jid_string =~ s/hold_jid ,/hold_jid /;
		# }	
		
		my $memory_allocation;
		if($numberFiles == 1){
			$memory_allocation = 'h_vmem=200G';
		}else{
			$memory_allocation = 'h_vmem=300G';
		}
		
		$clusterCommand = "echo \"$command\" | qsub -clear -b n -V -cwd -l $memory_allocation -pe cores 4 -o $prefix2Rand.out -j y -N $currentJobName $config{email} $jid_string";	
	
		#print "$clusterCommand\n";
	#	print "$command\n";
		
	#	!system("$command") or die "Could not run '$command' : $!";
		
		print LOG "CHiCAGO_Step2:\t$clusterCommand\n";	
		!system("$clusterCommand") or die "Could not run '$clusterCommand' : $!";	

}
		
close LOG or die "Could not close 'chicagoLog.txt' : $!";

print "Processing complete.\n";	

#print Dumper \%config;
	
exit (0);



###########################################################################
#Subroutines
############################################################################



#Takes the prefix for Step 1 and calculates the path and name of the
#file produced by CHiCAGO step1
sub calcStep1Outfile{
	my $prefix = $_[0];
	my $outFile = 'sample_' . $prefix . '/' . $prefix . '_bait_otherEnd_N_len_distSign.txt';
	return $outFile;
}



#Create a random letter string
#Takes a number for the length of
#the string and returns the string
sub generateRandomString{
	my $length = $_[0];
	
	my @chars = ("A".."Z", "a".."z");
	my $string;
	$string .= $chars[rand @chars] for 1..$length;
	
	return $string;
}






#Confirms that output directory, features file,
#data files baits and digest fragments exist
sub check_parameters{
	my $parameters_ok = 1;
	
	#Determine digest and bait filenames
	if( hasval($config{basename}) ){
		$baits = $config{basename} . '_baits_ID.bed';
		$digest = $config{basename} . '.bed';
	}else{
		warn "Please specify a --basename of digest files\n";
		$parameters_ok = 0;
	}
	
	#Add path to digest and bait filenames
	if( hasval ($config{digestfolder}) ){	
		$config{digestfolder} = $config{digestfolder} . '/' unless $config{digestfolder} =~ /\/$/;	
		$baits = $config{digestfolder} .$baits;
		$digest = $config{digestfolder} .$digest;
	}else{
		$config{digestfolder} = './';
		warn "Using current working directory as digest folder\n";
	}
	
	#Check baits exist
	if(hasval($baits) ){
		unless(-e $baits){
			warn "Baits file '$baits' does not exist\n";
			$parameters_ok = 0;
		}
	}

	#Check digest exists
	if(hasval($digest) ){
		unless(-e $digest){
			warn "Digest file '$digest' does not exist\n";
			$parameters_ok = 0;
		}
	}
	
	if(hasval ($config{input}) ){
		unless(-e $config{input}){
			warn "Input file '$config{input}' does not exist\n";
			$parameters_ok = 0;
		}
	}else{
		warn "Please specify an --input file\n";
		$parameters_ok = 0;		
	}
	
	if( hasval($config{email}) ){
		$config{email} = '-m eas -M ' . $config{email};
	}
	

	die "Please adjust configuration.\n" unless($parameters_ok);
}




#Subroutine: processInputfile
#Reads the inputfile and creates a datastructure
#Checks the data files exist
sub processInputfile{

	my $parameters_ok = 1;

	open(IN, '<', $config{input}) or die "Could not open '$config{input}' : $!";
	while(<IN>){
		my $line = $_;
		chomp $line;
		
		next if($line =~ /^\s*$/);
		
		my @lineArray = split(/\t/, $line);
		push(@inputData, [@lineArray]);
	
	
	}	
	close IN or die "Could not close $config{input}; : $!";
	
	#Check all input data files exit
	foreach my $array (@inputData){
		unless( -e $$array[0]){
			warn "Data file '$$array[0]' does not exist\n";
			$parameters_ok = 0;
		}	
	}
	
	#Check that all prefix1 entries are unique
	my %prefix1Count;
	foreach my $array (@inputData){
		if( hasval($$array[1]) ){
			$prefix1Count{$$array[1]}++;
		}	
	}
	foreach my $prefix1 (keys %prefix1Count){
		if($prefix1Count{$prefix1} > 1){
			warn "Prefix for step1 '$prefix1' appears $prefix1Count{$prefix1} times in the file '$config{input}'\n";
			$parameters_ok = 0;
		}
	}	
	
	
	#Check output directories don't already exist
	my %outputDirectories;
	my $alreadyExist = 0;
	foreach my $array (@inputData){
		my $step1Name = 'sample_' . $$array[1];
		my $step2Name = 'res_' . $$array[2];    #Check 'res' is output from CHiCAGO
	
		$outputDirectories{$step1Name} = '';    #Output folder name
		$outputDirectories{$step2Name} = '';    #Output folder name
	}
	
	foreach my $directory (keys %outputDirectories){
		$directory = $directory;
		if(-d $directory){
			warn "Output directory '$directory' already exists\n";
			$alreadyExist = 1;
		}
	}
	
	if($alreadyExist){
		my $reply = '';
		while( ($reply ne 'YES') and ($reply ne 'NO') ){
			warn "Do you want to overwrite the file in the output directories that alread exist [YES/NO]?\n";
			$reply = <STDIN>;
			chomp $reply;
			$reply = uc $reply;
		}
		
		if($reply eq 'NO'){
			$parameters_ok = 0;
		}
	
	}
	
	die "Please adjust configuration.\n" unless($parameters_ok);


}










############################
#Subroutine "process_config":
#Takes i) configuration file name and ii) %config hash (as a reference).
#The script then uses the configuration file to populate the hash as
#appropriate. Parameters passed via the command line take priority
#over those defined in the configuration file.
#The script modifies the hash directly, but returns as an array the lines in the configuration
#file that could did not correspond configuration parameters (these should be filenames).
sub process_config {
    my ( $config_file, $config_hash_ref ) = @_;
    my @non_parameters;    #Stores lines in the configuration file not defined as parameters

    #Open configuration file
    open( CONF, "$config_file" ) or die "Can't read $config_file: $!";

    while (<CONF>) {

        my $line = $_;
        chomp $line;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;    #Remove starting/trailing white spaces

        next if $line =~ /^\s*\#/;    #Ignore comments
        next if $line =~ /^\s*$/;     #Ignore whitespace


		
        #Check if this is a parameter
        my ( $parameter, $setting ) = split( /:/, $line );
        $parameter =~ s/^\s+//;
        $parameter =~ s/\s+$//;       #Remove starting/trailing white spaces
        $parameter = lc $parameter;
		$setting =~ s/^\s+// if defined ($setting);
        $setting =~ s/\s+$// if defined ($setting); 

		print "$parameter\t$setting\t\n";
		
        if ( exists $$config_hash_ref{$parameter} ) {
            if ( $$config_hash_ref{$parameter} eq '' ) {    #Check parameter not assigned value in command line
                $$config_hash_ref{$parameter} = $setting;    #Edit the configuration hash
            }
        } else {
            push( @non_parameters, $line );
        }
    }
    close CONF or die "Could not close filhandle on configuration file: '$config_file'\n";

    return @non_parameters;
}


###############################################################
#Sub: hasval
#Takes a string and returns true (i.e. '1') if the string has a value
#(i.e. is not equal to nothing (''). This is useful since some
#variables may be set to nothing allowing them to be evaluated
#without initialisation errors, while simultaneously containing
#no information.
sub hasval {
    if ( $_[0] ne '' ) {
        return 1;
    } else {
        return 0;
    }
}





__DATA__

The chicago Perl script controls the other programs in the CHiCAGO pipeline

SYNOPSIS

CHiCAGO [OPTIONS]... [Configuration FILE]...

FUNCTION





COMMAND LINE OPTIONS

--config         Specify the configuration file
--help	         Print program help and exit
--version        Print the program version and exit






